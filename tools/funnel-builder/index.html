<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Funnel Builder — Marketing Analytics</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        *,
        *::before,
        *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #f5f5f7;
            --grid-dot: #d1d1d6;
            --node-bg: #ffffff;
            --node-border: #ddd;
            --node-border-selected: #4361ee;
            --node-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            --node-shadow-selected: 0 2px 12px rgba(67, 97, 238, 0.25);
            --text-primary: #1a1a2e;
            --text-secondary: #555;
            --text-muted: #999;
            --primary: #4361ee;
            --primary-light: #eef0ff;
            --primary-hover: #3651d4;
            --danger: #e63946;
            --danger-hover: #c5303c;
            --panel-bg: #fff;
            --panel-border: #e8e8e8;
            --toolbar-bg: rgba(255, 255, 255, 0.95);
            --toolbar-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            --input-bg: #f5f5f7;
            --input-border: #ddd;
            --input-focus: #4361ee;
            --edge-color: #999;
            --edge-selected: #4361ee;
            --port-color: #bbb;
            --port-hover: #4361ee;
        }

        html,
        body,
        #root {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Inter', -apple-system, sans-serif;
            color: var(--text-primary);
            background: var(--bg);
        }

        .app {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* === Toolbar === */
        .toolbar {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: var(--toolbar-bg);
            backdrop-filter: blur(12px);
            border-radius: 12px;
            box-shadow: var(--toolbar-shadow);
            border: 1px solid var(--panel-border);
        }

        .toolbar-back {
            text-decoration: none;
            color: var(--text-secondary);
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 8px;
            transition: background 0.15s;
        }

        .toolbar-back:hover {
            background: var(--input-bg);
        }

        .toolbar-title {
            font-weight: 600;
            font-size: 14px;
            padding: 0 8px;
            white-space: nowrap;
        }

        .toolbar-sep {
            width: 1px;
            height: 24px;
            background: var(--panel-border);
            margin: 0 4px;
        }

        .toolbar-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 6px 12px;
            font-size: 13px;
            font-family: inherit;
            font-weight: 500;
            border: 1px solid var(--input-border);
            border-radius: 8px;
            background: #fff;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }

        .toolbar-btn:hover {
            background: var(--input-bg);
            border-color: #ccc;
        }

        .toolbar-btn.primary {
            background: var(--primary);
            color: #fff;
            border-color: var(--primary);
        }

        .toolbar-btn.primary:hover {
            background: var(--primary-hover);
        }

        .toolbar-btn.danger {
            color: var(--danger);
            border-color: var(--danger);
        }

        .toolbar-btn.danger:hover {
            background: #fff0f0;
        }

        .toolbar-btn svg {
            width: 15px;
            height: 15px;
        }

        .toolbar-zoom {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .zoom-btn {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--input-border);
            border-radius: 8px;
            background: #fff;
            cursor: pointer;
            font-size: 16px;
            color: var(--text-secondary);
            transition: all 0.15s;
        }

        .zoom-btn:hover {
            background: var(--input-bg);
        }

        .zoom-label {
            font-size: 12px;
            color: var(--text-muted);
            min-width: 40px;
            text-align: center;
        }

        /* === Canvas === */
        .canvas-viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            cursor: grab;
        }

        .canvas-viewport.select-mode {
            cursor: default;
        }

        .canvas-viewport.panning {
            cursor: grabbing;
        }

        .canvas-viewport.connecting {
            cursor: crosshair;
        }

        .cursor-mode-toggle {
            display: flex;
            align-items: center;
            gap: 2px;
            background: var(--input-bg);
            border-radius: 8px;
            padding: 2px;
            border: 1px solid var(--input-border);
        }

        .cursor-mode-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 28px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s;
        }

        .cursor-mode-btn:hover {
            background: rgba(0, 0, 0, 0.06);
            color: var(--text-primary);
        }

        .cursor-mode-btn.active {
            background: var(--primary);
            color: #fff;
            box-shadow: 0 1px 3px rgba(67, 97, 238, 0.3);
        }

        .cursor-mode-btn svg {
            width: 16px;
            height: 16px;
        }

        .canvas-transform {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
        }

        .edges-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            overflow: visible;
            pointer-events: none;
            z-index: 1;
        }

        .edge-path {
            fill: none;
            stroke: var(--edge-color);
            stroke-width: 2;
            pointer-events: stroke;
            cursor: pointer;
        }

        .edge-path:hover {
            stroke: var(--primary);
            stroke-width: 3;
        }

        .edge-path.selected {
            stroke: var(--edge-selected);
            stroke-width: 2.5;
        }

        .temp-edge {
            fill: none;
            stroke: var(--primary);
            stroke-width: 2;
            stroke-dasharray: 6 4;
            pointer-events: none;
        }

        /* === Nodes === */
        .funnel-node {
            position: absolute;
            width: 200px;
            background: var(--node-bg);
            border: 2px solid var(--node-border);
            border-radius: 12px;
            box-shadow: var(--node-shadow);
            cursor: grab;
            user-select: none;
            z-index: 2;
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        .funnel-node:hover {
            border-color: #ccc;
        }

        .funnel-node.selected {
            border-color: var(--node-border-selected);
            box-shadow: var(--node-shadow-selected);
        }

        .funnel-node.dragging {
            cursor: grabbing;
            z-index: 10;
            opacity: 0.92;
        }

        .node-header {
            padding: 10px 14px 6px;
            font-weight: 600;
            font-size: 13px;
            color: var(--text-primary);
            border-bottom: 1px solid #f0f0f0;
        }

        .node-metrics {
            padding: 8px 14px 10px;
        }

        .node-metric {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 2px 0;
            display: flex;
            justify-content: space-between;
        }

        .node-metric-label {
            color: var(--text-muted);
        }

        .node-metric-value {
            font-weight: 600;
            color: var(--text-primary);
        }

        .node-no-metrics {
            font-size: 11px;
            color: var(--text-muted);
            font-style: italic;
            padding: 4px 0;
        }

        /* Ports */
        .node-port {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid var(--port-color);
            top: 50%;
            transform: translateY(-50%);
            cursor: crosshair;
            z-index: 5;
            transition: all 0.15s;
        }

        .node-port:hover {
            border-color: var(--port-hover);
            background: var(--primary-light);
            transform: translateY(-50%) scale(1.3);
        }

        .node-port.port-input {
            left: -9px;
        }

        .node-port.port-output {
            right: -9px;
        }

        .node-port.connectable {
            border-color: var(--primary);
            background: var(--primary-light);
            animation: pulse-port 1s infinite;
        }

        @keyframes pulse-port {

            0%,
            100% {
                transform: translateY(-50%) scale(1);
            }

            50% {
                transform: translateY(-50%) scale(1.4);
            }
        }

        /* === Global Filter Node === */
        .global-filter-node {
            position: absolute;
            width: 220px;
            background: linear-gradient(135deg, #fff5e6 0%, #ffffff 100%);
            border: 2px solid #f59e0b;
            border-radius: 12px;
            box-shadow: var(--node-shadow);
            cursor: grab;
            user-select: none;
            z-index: 2;
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        .global-filter-node:hover {
            border-color: #d97706;
        }

        .global-filter-node.selected {
            border-color: #f59e0b;
            box-shadow: 0 2px 12px rgba(245, 158, 11, 0.3);
        }

        .global-filter-node.dragging {
            cursor: grabbing;
            z-index: 10;
            opacity: 0.92;
        }

        .global-filter-header {
            padding: 10px 14px 6px;
            font-weight: 600;
            font-size: 13px;
            color: #78350f;
            border-bottom: 1px solid #fed7aa;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .global-filter-header svg {
            width: 16px;
            height: 16px;
            stroke: #f59e0b;
        }

        .global-filter-body {
            padding: 8px 14px 10px;
        }

        .global-filter-summary {
            font-size: 11px;
            color: #78350f;
            padding: 4px 8px;
            background: rgba(245, 158, 11, 0.1);
            border-radius: 6px;
            margin-bottom: 4px;
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
        }

        .global-filter-summary-label {
            font-weight: 600;
        }

        .global-filter-summary-operator {
            color: #92400e;
            font-weight: 500;
        }

        .global-filter-summary-value {
            font-weight: 600;
            color: #78350f;
        }

        .global-filter-no-filters {
            font-size: 11px;
            color: #92400e;
            font-style: italic;
            padding: 4px 0;
        }

        .global-filter-count {
            font-size: 10px;
            color: #92400e;
            padding: 4px 0;
            font-weight: 500;
        }

        /* === Stream Filter Node === */
        .stream-filter-node {
            position: absolute;
            width: 220px;
            background: linear-gradient(135deg, #e0f2fe 0%, #ffffff 100%);
            border: 2px solid #0ea5e9;
            border-radius: 12px;
            box-shadow: var(--node-shadow);
            cursor: grab;
            user-select: none;
            z-index: 2;
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        .stream-filter-node:hover {
            border-color: #0284c7;
        }

        .stream-filter-node.selected {
            border-color: #0ea5e9;
            box-shadow: 0 2px 12px rgba(14, 165, 233, 0.3);
        }

        .stream-filter-node.dragging {
            cursor: grabbing;
            z-index: 10;
            opacity: 0.92;
        }

        .stream-filter-header {
            padding: 10px 14px 6px;
            font-weight: 600;
            font-size: 13px;
            color: #075985;
            border-bottom: 1px solid #bae6fd;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stream-filter-header svg {
            width: 16px;
            height: 16px;
            stroke: #0ea5e9;
        }

        .stream-filter-body {
            padding: 8px 14px 10px;
        }

        .stream-filter-summary {
            font-size: 11px;
            color: #075985;
            padding: 4px 8px;
            background: rgba(14, 165, 233, 0.1);
            border-radius: 6px;
            margin-bottom: 4px;
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
        }

        .stream-filter-summary-label {
            font-weight: 600;
        }

        .stream-filter-summary-operator {
            color: #0c4a6e;
            font-weight: 500;
        }

        .stream-filter-summary-value {
            font-weight: 600;
            color: #075985;
        }

        .stream-filter-no-filters {
            font-size: 11px;
            color: #0c4a6e;
            font-style: italic;
            padding: 4px 0;
        }

        .stream-filter-count {
            font-size: 10px;
            color: #0c4a6e;
            padding: 4px 0;
            font-weight: 500;
        }

        /* === Text Labels === */
        .text-label {
            position: absolute;
            z-index: 4;
            padding: 8px 12px;
            background: transparent;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: grab;
            user-select: none;
            transition: border-color 0.15s, background-color 0.15s;
            min-width: 60px;
            text-align: center;
        }

        .text-label:hover {
            border-color: rgba(0, 0, 0, 0.1);
        }

        .text-label.selected {
            border-color: var(--primary);
            background: rgba(67, 97, 238, 0.05);
        }

        .text-label.dragging {
            cursor: grabbing;
            opacity: 0.9;
        }

        .text-label-content {
            white-space: pre-wrap;
            pointer-events: none;
            color: var(--text-primary);
        }

        /* === Edge Labels === */
        .edge-label-container {
            position: absolute;
            z-index: 3;
            pointer-events: none;
        }

        .edge-label {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 6px 10px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
            transform: translate(-50%, -50%);
            white-space: nowrap;
            pointer-events: auto;
            cursor: pointer;
        }

        .edge-label.selected {
            border-color: var(--primary);
        }

        .edge-label-row {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .edge-label-value {
            font-weight: 600;
            color: var(--text-primary);
        }

        /* === Properties Panel === */
        .panel-overlay {
            position: fixed;
            top: 0;
            right: 0;
            width: 340px;
            height: 100%;
            background: var(--panel-bg);
            border-left: 1px solid var(--panel-border);
            box-shadow: -4px 0 16px rgba(0, 0, 0, 0.06);
            z-index: 200;
            overflow-y: auto;
            animation: slideIn 0.2s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
            }

            to {
                transform: translateX(0);
            }
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--panel-border);
            position: sticky;
            top: 0;
            background: var(--panel-bg);
            z-index: 1;
        }

        .panel-title {
            font-weight: 600;
            font-size: 15px;
        }

        .panel-close {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: none;
            cursor: pointer;
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 18px;
            transition: background 0.15s;
        }

        .panel-close:hover {
            background: var(--input-bg);
            color: var(--text-primary);
        }

        .panel-body {
            padding: 20px;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .panel-field {
            margin-bottom: 12px;
        }

        .panel-field label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .panel-field input,
        .panel-field textarea {
            width: 100%;
            padding: 8px 10px;
            font-size: 13px;
            font-family: inherit;
            border: 1px solid var(--input-border);
            border-radius: 8px;
            background: var(--input-bg);
            color: var(--text-primary);
            outline: none;
            transition: border-color 0.15s;
        }

        .panel-field input:focus,
        .panel-field textarea:focus {
            border-color: var(--input-focus);
            background: #fff;
        }

        .panel-field textarea {
            resize: vertical;
            min-height: 60px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 12px;
        }

        .metric-card {
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .metric-card .panel-field {
            margin-bottom: 8px;
        }

        .metric-card .panel-field:last-child {
            margin-bottom: 0;
        }

        .filter-card {
            background: #fef9e7;
            border-color: #f9e79f;
        }

        .csv-metric-card {
            background: #eef4ff;
            border-color: #c3d9ff;
        }

        .derived-metric-card {
            background: #e8faf0;
            border-color: #86d4a8;
        }

        .derived-metric-card.disconnected {
            border-color: #f9a825;
            border-width: 2px;
        }

        .metric-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .metric-card-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .metric-delete-btn {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: none;
            cursor: pointer;
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 14px;
            transition: all 0.15s;
        }

        .metric-delete-btn:hover {
            background: #fee;
            color: var(--danger);
        }

        .add-btn {
            width: 100%;
            padding: 8px;
            font-size: 12px;
            font-weight: 500;
            font-family: inherit;
            border: 1px dashed var(--input-border);
            border-radius: 8px;
            background: none;
            color: var(--primary);
            cursor: pointer;
            transition: all 0.15s;
        }

        .add-btn:hover {
            background: var(--primary-light);
            border-color: var(--primary);
        }

        .delete-section {
            padding-top: 16px;
            border-top: 1px solid var(--panel-border);
        }

        .duplicate-btn {
            width: 100%;
            padding: 10px;
            font-size: 13px;
            font-weight: 500;
            font-family: inherit;
            border: 1px solid var(--primary);
            background: var(--primary-light);
            color: var(--primary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s;
            margin-bottom: 8px;
        }

        .duplicate-btn:hover {
            background: var(--primary);
            color: #fff;
        }

        .delete-btn {
            width: 100%;
            padding: 10px;
            font-size: 13px;
            font-weight: 500;
            font-family: inherit;
            border: 1px solid var(--danger);
            border-radius: 8px;
            background: none;
            color: var(--danger);
            cursor: pointer;
            transition: all 0.15s;
        }

        .delete-btn:hover {
            background: var(--danger);
            color: #fff;
        }

        .edge-info {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 8px 10px;
            background: var(--input-bg);
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .edge-info span {
            font-weight: 600;
            color: var(--text-primary);
        }

        .var-hint {
            font-size: 11px;
            color: var(--text-muted);
            background: var(--input-bg);
            border-radius: 8px;
            padding: 8px 10px;
            line-height: 1.6;
        }

        .var-hint code {
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 11px;
            background: #e8e8ec;
            padding: 1px 4px;
            border-radius: 3px;
            color: var(--primary);
        }

        .calc-result {
            font-size: 12px;
            padding: 4px 0;
            color: var(--text-muted);
        }

        .calc-result strong {
            color: var(--primary);
        }

        /* === Node Color Picker === */
        .color-picker {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.15s;
        }

        .color-swatch:hover {
            transform: scale(1.15);
        }

        .color-swatch.active {
            border-color: var(--primary) !important;
            box-shadow: 0 0 0 2px var(--primary-light);
        }

        /* === Empty State === */
        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 0;
            pointer-events: none;
        }

        .empty-state h2 {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .empty-state p {
            font-size: 14px;
            color: var(--text-muted);
            line-height: 1.6;
        }

        .empty-state .hint {
            display: inline-block;
            margin-top: 12px;
            padding: 6px 12px;
            font-size: 12px;
            background: var(--primary-light);
            color: var(--primary);
            border-radius: 8px;
            font-weight: 500;
        }

        /* === Confirm Modal === */
        .confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 300;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .confirm-modal {
            background: #fff;
            border-radius: 16px;
            padding: 24px;
            width: 360px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        }

        .confirm-modal h3 {
            font-size: 16px;
            margin-bottom: 8px;
        }

        .confirm-modal p {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .confirm-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .confirm-actions button {
            padding: 8px 16px;
            font-size: 13px;
            font-family: inherit;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .confirm-cancel {
            border: 1px solid var(--input-border);
            background: #fff;
            color: var(--text-primary);
        }

        .confirm-cancel:hover {
            background: var(--input-bg);
        }

        .confirm-danger {
            border: 1px solid var(--danger);
            background: var(--danger);
            color: #fff;
        }

        .confirm-danger:hover {
            background: var(--danger-hover);
        }

        /* Privacy badge */
        .privacy-badge {
            position: fixed;
            bottom: 16px;
            left: 16px;
            z-index: 50;
            font-size: 11px;
            color: var(--text-muted);
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: 8px;
            border: 1px solid var(--panel-border);
        }

        .hidden-input {
            display: none;
        }

        /* === Responsive === */
        @media (max-width: 768px) {
            .toolbar {
                top: 8px;
                padding: 6px 8px;
                gap: 4px;
                max-width: calc(100vw - 16px);
                overflow-x: auto;
            }

            .toolbar-title {
                font-size: 12px;
                padding: 0 4px;
            }

            .toolbar-btn {
                padding: 5px 8px;
                font-size: 12px;
            }

            .panel-overlay {
                width: 100%;
                max-width: 340px;
            }
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useCallback, useEffect, useRef, useMemo } = React;

        // ========================
        // Constants
        // ========================
        const NODE_WIDTH = 200;
        const NODE_HEADER_H = 36;
        const NODE_METRIC_H = 24;
        const NODE_PADDING_Y = 20;
        const GRID_SIZE = 24;
        const STORAGE_KEY = 'funnel-builder-data';

        const NODE_COLORS = [
            { name: 'Default', bg: '#ffffff', border: '#ddd' },
            { name: 'Blue', bg: '#dbeafe', border: '#93c5fd' },
            { name: 'Green', bg: '#dcfce7', border: '#86efac' },
            { name: 'Yellow', bg: '#fef9c3', border: '#fde047' },
            { name: 'Red', bg: '#fee2e2', border: '#fca5a5' },
            { name: 'Purple', bg: '#f3e8ff', border: '#d8b4fe' },
        ];

        // ========================
        // Utilities
        // ========================
        let idCounter = 0;
        function genId(prefix = 'id') {
            return `${prefix}-${Date.now()}-${++idCounter}`;
        }

        function getNodeWidth(node) {
            if (node.type === 'global-filter' || node.type === 'stream-filter') {
                return 220; // Filter nodes are wider
            }
            return NODE_WIDTH; // 200px for regular nodes
        }

        function getNodeHeight(node) {
            if (node.type === 'global-filter') {
                const filterCount = (node.globalFilters || []).length;
                return NODE_PADDING_Y + NODE_HEADER_H + Math.max(filterCount, 1) * NODE_METRIC_H;
            }
            if (node.type === 'stream-filter') {
                const filterCount = (node.streamFilters || []).length;
                return NODE_PADDING_Y + NODE_HEADER_H + Math.max(filterCount, 1) * NODE_METRIC_H;
            }
            // Regular nodes - add defensive fallback
            const metricsCount = Math.max((node.metrics || []).length, 1);
            return NODE_PADDING_Y + NODE_HEADER_H + metricsCount * NODE_METRIC_H;
        }

        function getOutputPort(node) {
            const h = getNodeHeight(node);
            return { x: node.position.x + NODE_WIDTH, y: node.position.y + h / 2 };
        }

        function getInputPort(node) {
            const h = getNodeHeight(node);
            return { x: node.position.x, y: node.position.y + h / 2 };
        }

        function getBezierPath(src, tgt) {
            const dx = Math.max(Math.abs(tgt.x - src.x) * 0.5, 60);
            return `M ${src.x} ${src.y} C ${src.x + dx} ${src.y}, ${tgt.x - dx} ${tgt.y}, ${tgt.x} ${tgt.y}`;
        }

        function bezierMidpoint(src, tgt) {
            const dx = Math.max(Math.abs(tgt.x - src.x) * 0.5, 60);
            const t = 0.5;
            const u = 1 - t;
            const p0 = src, p1 = { x: src.x + dx, y: src.y }, p2 = { x: tgt.x - dx, y: tgt.y }, p3 = tgt;
            return {
                x: u * u * u * p0.x + 3 * u * u * t * p1.x + 3 * u * t * t * p2.x + t * t * t * p3.x,
                y: u * u * u * p0.y + 3 * u * u * t * p1.y + 3 * u * t * t * p2.y + t * t * t * p3.y,
            };
        }

        function snapToGrid(val) {
            return Math.round(val / GRID_SIZE) * GRID_SIZE;
        }

        // Sanitize a node label to create a valid identifier for expressions
        function sanitizeLabel(label) {
            if (!label) return 'node';
            return label.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '') || 'node';
        }

        // Build a map of source node references for a given node
        // Returns { sanitizedLabel: nodeObject, ... } plus 'source' alias if there's exactly one source
        function buildSourceRefMap(nodeId, edges, resolvedNodesMap) {
            const refMap = {};
            const labelCounts = {};

            // Find all incoming edges
            const incomingEdges = edges.filter(edge => edge.to === nodeId);

            // First pass: sanitize labels and track duplicates
            const sourceNodes = incomingEdges.map(edge => {
                const sourceNode = resolvedNodesMap[edge.from];
                if (!sourceNode) return null;

                const sanitized = sanitizeLabel(sourceNode.label);
                labelCounts[sanitized] = (labelCounts[sanitized] || 0) + 1;

                return { sourceNode, sanitized };
            }).filter(Boolean);

            // Second pass: build map with disambiguation
            const usedLabels = {};
            sourceNodes.forEach(({ sourceNode, sanitized }) => {
                let finalLabel = sanitized;

                // If duplicate, add suffix
                if (labelCounts[sanitized] > 1) {
                    const count = (usedLabels[sanitized] || 0) + 1;
                    usedLabels[sanitized] = count;
                    finalLabel = count === 1 ? sanitized : `${sanitized}_${count}`;
                }

                refMap[finalLabel] = sourceNode;
            });

            // Add 'source' alias if there's exactly one source node
            if (sourceNodes.length === 1) {
                refMap['source'] = sourceNodes[0].sourceNode;
            }

            return refMap;
        }

        // Safe math expression evaluator (recursive descent parser — no eval)
        function safeEvaluate(expr) {
            const tokens = [];
            let i = 0;
            const s = expr.trim();
            while (i < s.length) {
                if (/\s/.test(s[i])) { i++; continue; }
                if (/[\d.]/.test(s[i])) {
                    let num = '';
                    while (i < s.length && /[\d.]/.test(s[i])) num += s[i++];
                    tokens.push({ type: 'num', value: parseFloat(num) });
                } else if ('+-*/()'.includes(s[i])) {
                    tokens.push({ type: 'op', value: s[i++] });
                } else {
                    return NaN;
                }
            }
            let pos = 0;
            function peek() { return pos < tokens.length ? tokens[pos] : null; }
            function consume() { return tokens[pos++]; }
            function parseExpr() {
                let left = parseTerm();
                while (peek() && (peek().value === '+' || peek().value === '-')) {
                    const op = consume().value;
                    const right = parseTerm();
                    left = op === '+' ? left + right : left - right;
                }
                return left;
            }
            function parseTerm() {
                let left = parseUnary();
                while (peek() && (peek().value === '*' || peek().value === '/')) {
                    const op = consume().value;
                    const right = parseUnary();
                    left = op === '*' ? left * right : left / right;
                }
                return left;
            }
            function parseUnary() {
                if (peek() && peek().value === '-') { consume(); return -parseFactor(); }
                if (peek() && peek().value === '+') { consume(); return parseFactor(); }
                return parseFactor();
            }
            function parseFactor() {
                if (peek() && peek().value === '(') {
                    consume();
                    const val = parseExpr();
                    if (peek() && peek().value === ')') consume();
                    return val;
                }
                if (peek() && peek().type === 'num') return consume().value;
                return NaN;
            }
            try {
                const result = parseExpr();
                if (pos !== tokens.length) return NaN;
                return result;
            } catch { return NaN; }
        }

        function resolveExpression(expression, sourceNode, targetNode) {
            let resolved = expression || '';
            resolved = resolved.replace(/source\.(\w+)/g, (_, key) => {
                const m = sourceNode.metrics.find(m => m.key === key);
                return m ? String(Number(m.value) || 0) : '0';
            });
            resolved = resolved.replace(/target\.(\w+)/g, (_, key) => {
                const m = targetNode.metrics.find(m => m.key === key);
                return m ? String(Number(m.value) || 0) : '0';
            });
            return safeEvaluate(resolved);
        }

        function formatNumber(n) {
            if (isNaN(n) || !isFinite(n)) return '—';
            if (Number.isInteger(n)) return n.toLocaleString();
            return n.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
        }

        // Topological sort for computing derived metrics in dependency order
        function topologicalSort(nodes, edges) {
            const nodeIds = nodes.map(n => n.id);
            const inDegree = {};
            const adjList = {};

            // Initialize
            nodeIds.forEach(id => {
                inDegree[id] = 0;
                adjList[id] = [];
            });

            // Build adjacency list and in-degree count
            edges.forEach(edge => {
                if (nodeIds.includes(edge.from) && nodeIds.includes(edge.to)) {
                    adjList[edge.from].push(edge.to);
                    inDegree[edge.to]++;
                }
            });

            // Kahn's algorithm
            const queue = [];
            const sorted = [];
            const cyclic = new Set();

            // Start with nodes that have no incoming edges
            nodeIds.forEach(id => {
                if (inDegree[id] === 0) {
                    queue.push(id);
                }
            });

            while (queue.length > 0) {
                const current = queue.shift();
                sorted.push(current);

                adjList[current].forEach(neighbor => {
                    inDegree[neighbor]--;
                    if (inDegree[neighbor] === 0) {
                        queue.push(neighbor);
                    }
                });
            }

            // Detect cycles: any node with in-degree > 0 is part of a cycle
            nodeIds.forEach(id => {
                if (inDegree[id] > 0) {
                    cyclic.add(id);
                }
            });

            return { sorted, cyclic };
        }

        // Compute derived metrics for a node using resolved source nodes
        function computeDerivedMetrics(node, edges, resolvedNodesMap) {
            if (!node.derivedMetrics || node.derivedMetrics.length === 0) {
                return [];
            }

            // Build source reference map for this node
            const sourceRefMap = buildSourceRefMap(node.id, edges, resolvedNodesMap);

            return node.derivedMetrics.map(dm => {
                // Resolve the expression using ALL source nodes' metrics
                let resolved = dm.expression || '';

                // Replace <identifier>.<key> patterns with metric values
                resolved = resolved.replace(/(\w+)\.(\w+)/g, (match, identifier, key) => {
                    const sourceNode = sourceRefMap[identifier];
                    if (!sourceNode) {
                        return '0'; // Identifier not found in sources
                    }

                    const metric = sourceNode.metrics.find(m => m.key === key);
                    return metric ? String(Number(metric.value) || 0) : '0';
                });

                const result = safeEvaluate(resolved);
                return { key: dm.key, label: dm.label, value: result };
            });
        }

        // CSV Parser - handles quoted fields, treats first row as headers
        function parseCSV(text) {
            const lines = [];
            let currentLine = [];
            let currentField = '';
            let inQuotes = false;
            let i = 0;

            // Parse character by character to handle quoted fields
            while (i < text.length) {
                const char = text[i];
                const nextChar = text[i + 1];

                if (inQuotes) {
                    if (char === '"' && nextChar === '"') {
                        // Escaped quote
                        currentField += '"';
                        i += 2;
                    } else if (char === '"') {
                        // End of quoted field
                        inQuotes = false;
                        i++;
                    } else {
                        // Inside quoted field
                        currentField += char;
                        i++;
                    }
                } else {
                    if (char === '"') {
                        // Start of quoted field
                        inQuotes = true;
                        i++;
                    } else if (char === ',') {
                        // Field separator
                        currentLine.push(currentField.trim());
                        currentField = '';
                        i++;
                    } else if (char === '\n' || (char === '\r' && nextChar === '\n')) {
                        // Line separator
                        currentLine.push(currentField.trim());
                        if (currentLine.some(f => f.length > 0)) {
                            lines.push(currentLine);
                        }
                        currentLine = [];
                        currentField = '';
                        i += (char === '\r' && nextChar === '\n') ? 2 : 1;
                    } else {
                        // Regular character
                        currentField += char;
                        i++;
                    }
                }
            }

            // Handle last field and line
            currentLine.push(currentField.trim());
            if (currentLine.some(f => f.length > 0)) {
                lines.push(currentLine);
            }

            if (lines.length === 0) return { headers: [], rows: [] };

            // First row is headers
            const rawHeaders = lines[0];
            const sanitizeKey = (str) => str.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
            const headers = rawHeaders.map(sanitizeKey);

            // Convert remaining rows to objects
            const rows = [];
            for (let j = 1; j < lines.length; j++) {
                const row = {};
                const values = lines[j];
                for (let k = 0; k < headers.length; k++) {
                    row[headers[k]] = values[k] || '';
                }
                rows.push(row);
            }

            return { headers, rows, rawHeaders };
        }

        // ========================
        // CSV Aggregation Engine
        // ========================
        const AGGREGATION_TYPES = ['SUM', 'AVG', 'COUNT', 'MIN', 'MAX', 'COUNT_DISTINCT'];

        function applyFilters(rows, filters) {
            if (!filters || filters.length === 0) return rows;

            return rows.filter(row => {
                return filters.every(filter => {
                    const { column, operator, value } = filter;
                    if (!column || !operator) return true; // Skip incomplete filters

                    const cellValue = row[column];

                    switch (operator) {
                        case 'equals': {
                            return String(cellValue).toLowerCase() === String(value).toLowerCase();
                        }
                        case 'not_equals': {
                            return String(cellValue).toLowerCase() !== String(value).toLowerCase();
                        }
                        case 'contains': {
                            return String(cellValue).toLowerCase().includes(String(value).toLowerCase());
                        }
                        case 'greater_than': {
                            const numCell = parseFloat(cellValue);
                            const numValue = parseFloat(value);
                            return !isNaN(numCell) && !isNaN(numValue) && numCell > numValue;
                        }
                        case 'less_than': {
                            const numCell = parseFloat(cellValue);
                            const numValue = parseFloat(value);
                            return !isNaN(numCell) && !isNaN(numValue) && numCell < numValue;
                        }
                        default:
                            return true;
                    }
                });
            });
        }

        function aggregate(rows, column, aggregationType) {
            if (!rows || rows.length === 0) return 0;

            switch (aggregationType) {
                case 'COUNT': {
                    return rows.length;
                }
                case 'SUM': {
                    return rows.reduce((sum, row) => {
                        const val = parseFloat(row[column]);
                        return sum + (isNaN(val) ? 0 : val);
                    }, 0);
                }
                case 'AVG': {
                    const numericValues = rows
                        .map(row => parseFloat(row[column]))
                        .filter(val => !isNaN(val));
                    if (numericValues.length === 0) return 0;
                    return numericValues.reduce((sum, val) => sum + val, 0) / numericValues.length;
                }
                case 'MIN': {
                    const numericValues = rows
                        .map(row => parseFloat(row[column]))
                        .filter(val => !isNaN(val));
                    if (numericValues.length === 0) return 0;
                    return Math.min(...numericValues);
                }
                case 'MAX': {
                    const numericValues = rows
                        .map(row => parseFloat(row[column]))
                        .filter(val => !isNaN(val));
                    if (numericValues.length === 0) return 0;
                    return Math.max(...numericValues);
                }
                case 'COUNT_DISTINCT': {
                    const uniqueValues = new Set(rows.map(row => row[column]));
                    return uniqueValues.size;
                }
                default:
                    return 0;
            }
        }

        // Collect all global filters from global-filter nodes
        function collectGlobalFilters(nodes) {
            return nodes
                .filter(node => node.type === 'global-filter')
                .flatMap(node => node.globalFilters || []);
        }

        // Collect all stream filters that affect a given node (from upstream stream-filter nodes)
        function collectUpstreamStreamFilters(nodeId, edges, nodesById) {
            const visited = new Set();
            const collectedFilters = [];

            function traverse(currentNodeId) {
                if (visited.has(currentNodeId)) return; // Prevent infinite loops
                visited.add(currentNodeId);

                // Find all incoming edges to this node
                const incomingEdges = edges.filter(e => e.to === currentNodeId);

                for (const edge of incomingEdges) {
                    const sourceNode = nodesById[edge.from];
                    if (!sourceNode) continue;

                    // If the source is a stream-filter node, collect its filters
                    if (sourceNode.type === 'stream-filter') {
                        const filters = sourceNode.streamFilters || [];
                        collectedFilters.push(...filters);
                        // Continue traversing upstream (transitive collection)
                        traverse(edge.from);
                    } else {
                        // Regular nodes: continue traversing upstream
                        traverse(edge.from);
                    }
                }
            }

            traverse(nodeId);

            // Return collected filters (AND combination - all filters apply)
            return collectedFilters;
        }

        function computeNodeMetrics(csvData, csvConfig, preFilteredRows) {
            if (!csvData || !csvConfig || !csvConfig.metrics || csvConfig.metrics.length === 0) {
                return [];
            }

            // Use pre-filtered rows if provided, otherwise use all rows
            const baseRows = preFilteredRows !== undefined ? preFilteredRows : csvData.rows;

            // Apply per-node filters on top of global filters
            const filteredRows = applyFilters(baseRows, csvConfig.filters || []);

            // Compute each metric
            return csvConfig.metrics.map(metricDef => {
                const { column, aggregation, key, label } = metricDef;
                const value = aggregate(filteredRows, column, aggregation);
                return { key, label, value };
            });
        }

        // ========================
        // App Component
        // ========================
        function App() {
            const [nodes, setNodes] = useState([]);
            const [edges, setEdges] = useState([]);
            const [textLabels, setTextLabels] = useState([]);

            const [selectedIds, setSelectedIds] = useState([]);
            const [selectionBox, setSelectionBox] = useState(null);
            const [cursorMode, setCursorMode] = useState('hand'); // 'hand' | 'select'
            const [clipboard, setClipboard] = useState({ nodes: [], textLabels: [] });

            const handleSelect = useCallback((id, e) => {
                if (e && e.shiftKey) {
                    setSelectedIds(prev => prev.includes(id) ? prev.filter(pid => pid !== id) : [...prev, id]);
                } else {
                    setSelectedIds(prev => prev.includes(id) ? prev : [id]);
                }
            }, []);

            const [connecting, setConnecting] = useState(null);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [viewport, setViewport] = useState({ x: 0, y: 0, zoom: 1 });
            const [isPanning, setIsPanning] = useState(false);
            const [confirmAction, setConfirmAction] = useState(null);
            const [csvData, setCsvData] = useState(null);
            const viewportRef = useRef(null);
            const fileInputRef = useRef(null);
            const csvFileInputRef = useRef(null);
            const panActiveRef = useRef(false);
            const initialLoadRef = useRef(false);
            const spacebarPressedRef = useRef(false);
            const nodesRef = useRef(nodes);
            const textLabelsRef = useRef(textLabels);
            const viewportStateRef = useRef(viewport);

            // Keep refs in sync with state
            useEffect(() => { nodesRef.current = nodes; }, [nodes]);
            useEffect(() => { textLabelsRef.current = textLabels; }, [textLabels]);
            useEffect(() => { viewportStateRef.current = viewport; }, [viewport]);

            // Load from localStorage on mount
            useEffect(() => {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const data = JSON.parse(saved);

                        // Migrate old csvRowIndex format to new csvConfig format
                        if (data.nodes) {
                            const migratedNodes = data.nodes.map(node => {
                                let migratedNode = { ...node };

                                // Migrate csvRowIndex (old format)
                                if (node.csvRowIndex !== undefined && !node.csvConfig) {
                                    const { csvRowIndex, ...rest } = migratedNode;
                                    migratedNode = { ...rest, csvConfig: null };
                                }

                                // Ensure derivedMetrics exists
                                if (!migratedNode.derivedMetrics) {
                                    migratedNode.derivedMetrics = [];
                                }

                                // Migrate old sourceNodeId format to new multi-source syntax
                                if (migratedNode.derivedMetrics && migratedNode.derivedMetrics.length > 0) {
                                    migratedNode.derivedMetrics = migratedNode.derivedMetrics.map(dm => {
                                        if (dm.sourceNodeId) {
                                            // Find the source node to get its label
                                            const sourceNode = data.nodes.find(n => n.id === dm.sourceNodeId);
                                            if (sourceNode) {
                                                const sanitized = sanitizeLabel(sourceNode.label);
                                                // Replace 'source.' with '<sanitized_label>.'
                                                const migratedExpression = (dm.expression || '').replace(/source\.(\w+)/g, `${sanitized}.$1`);

                                                // Remove sourceNodeId field
                                                const { sourceNodeId, ...rest } = dm;
                                                return { ...rest, expression: migratedExpression };
                                            }
                                            // If source node not found, keep as is but remove sourceNodeId
                                            const { sourceNodeId, ...rest } = dm;
                                            return rest;
                                        }
                                        return dm;
                                    });
                                }

                                // Ensure type field exists (default to 'node' for backward compatibility)
                                if (!migratedNode.type) {
                                    migratedNode.type = 'node';
                                }

                                return migratedNode;
                            });
                            setNodes(migratedNodes);
                        }

                        if (data.edges) setEdges(data.edges);
                        if (data.csvData) setCsvData(data.csvData);
                        if (data.textLabels) setTextLabels(data.textLabels);
                    }
                } catch { }
                initialLoadRef.current = true;
            }, []);

            // Auto-save to localStorage
            useEffect(() => {
                if (!initialLoadRef.current) return;
                const t = setTimeout(() => {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify({ nodes, edges, csvData, textLabels }));
                }, 300);
                return () => clearTimeout(t);
            }, [nodes, edges, csvData, textLabels]);

            // Keyboard shortcuts
            useEffect(() => {
                function handleKeyDown(e) {
                    // Track spacebar for canvas panning
                    if (e.key === ' ') {
                        spacebarPressedRef.current = true;
                    }

                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    if (e.key === 'Escape') {
                        setConnecting(null);
                        setSelectedIds([]);
                    }
                    if (e.key === 'v' || e.key === 'V') {
                        if (!e.ctrlKey && !e.metaKey) {
                            setCursorMode('select');
                        }
                    }
                    if (e.key === 'h' || e.key === 'H') {
                        setCursorMode('hand');
                    }
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (selectedIds.length > 0) {
                            setNodes(prev => prev.filter(n => !selectedIds.includes(n.id)));
                            setEdges(prev => prev.filter(e => !selectedIds.includes(e.from) && !selectedIds.includes(e.to) && !selectedIds.includes(e.id)));
                            setTextLabels(prev => prev.filter(l => !selectedIds.includes(l.id)));
                            setSelectedIds([]);
                        }
                    }
                    if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                        e.preventDefault();
                        selectedIds.forEach(id => {
                            duplicateNode(id);
                            duplicateTextLabel(id);
                        });
                    }
                    if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                        if (selectedIds.length > 0) {
                            // Copy selected objects to clipboard
                            const nodesToCopy = nodes.filter(n => selectedIds.includes(n.id));
                            const labelsToCopy = textLabels.filter(l => selectedIds.includes(l.id));
                            setClipboard({ nodes: nodesToCopy, textLabels: labelsToCopy });
                        }
                    }
                    if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                        if (clipboard.nodes.length > 0 || clipboard.textLabels.length > 0) {
                            e.preventDefault();
                            const newNodeIds = [];
                            const newLabelIds = [];

                            // Paste nodes
                            clipboard.nodes.forEach(node => {
                                const newId = genId('node');
                                const newNode = {
                                    ...node,
                                    id: newId,
                                    label: node.label + ' (copy)',
                                    position: {
                                        x: snapToGrid(node.position.x + 40),
                                        y: snapToGrid(node.position.y + 40),
                                    },
                                };
                                setNodes(prev => [...prev, newNode]);
                                newNodeIds.push(newId);
                            });

                            // Paste text labels
                            clipboard.textLabels.forEach(label => {
                                const newId = genId('text');
                                const newLabel = {
                                    ...label,
                                    id: newId,
                                    position: {
                                        x: snapToGrid(label.position.x + 40),
                                        y: snapToGrid(label.position.y + 40),
                                    },
                                };
                                setTextLabels(prev => [...prev, newLabel]);
                                newLabelIds.push(newId);
                            });

                            // Select the newly pasted objects
                            setSelectedIds([...newNodeIds, ...newLabelIds]);
                        }
                    }
                }

                function handleKeyUp(e) {
                    // Release spacebar tracking
                    if (e.key === ' ') {
                        spacebarPressedRef.current = false;
                    }
                }

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, [selectedIds, duplicateNode, duplicateTextLabel]);

            // ---- Node CRUD ----
            const addNode = useCallback((x, y) => {
                const node = {
                    id: genId('node'),
                    type: 'node',
                    label: 'New Node',
                    position: { x: snapToGrid(x), y: snapToGrid(y) },
                    metrics: [],
                    color: 0,
                    derivedMetrics: [],
                };
                setNodes(prev => [...prev, node]);
                setSelectedIds([node.id]);
            }, []);

            const addGlobalFilterNode = useCallback((x, y) => {
                const node = {
                    id: genId('global-filter'),
                    type: 'global-filter',
                    label: 'Global Filter',
                    position: { x: snapToGrid(x), y: snapToGrid(y) },
                    color: 3, // Use a distinct color for global filter nodes
                    globalFilters: [],
                };
                setNodes(prev => [...prev, node]);
                setSelectedIds([node.id]);
            }, []);

            const addStreamFilterNode = useCallback((x, y) => {
                const node = {
                    id: genId('stream-filter'),
                    type: 'stream-filter',
                    label: 'Stream Filter',
                    position: { x: snapToGrid(x), y: snapToGrid(y) },
                    color: 5, // Use purple/distinct color for stream filter nodes
                    streamFilters: [],
                };
                setNodes(prev => [...prev, node]);
                setSelectedIds([node.id]);
            }, []);

            const updateNode = useCallback((id, updates) => {
                setNodes(prev => prev.map(n => n.id === id ? { ...n, ...updates } : n));
            }, []);

            const deleteNode = useCallback((id) => {
                setNodes(prev => prev.filter(n => n.id !== id));
                setEdges(prev => prev.filter(e => e.from !== id && e.to !== id));
                setSelectedIds(prev => prev.filter(pid => pid !== id));
            }, []);

            const duplicateNode = useCallback((id) => {
                const source = nodes.find(n => n.id === id);
                if (!source) return;

                // Handle global filter nodes differently
                if (source.type === 'global-filter') {
                    const newNode = {
                        id: genId('global-filter'),
                        type: 'global-filter',
                        label: source.label + ' (copy)',
                        position: {
                            x: snapToGrid(source.position.x + 40),
                            y: snapToGrid(source.position.y + 40),
                        },
                        color: source.color,
                        globalFilters: (source.globalFilters || []).map(f => ({ ...f })),
                    };
                    setNodes(prev => [...prev, newNode]);
                    setSelectedIds([newNode.id]);
                    return;
                }

                // Handle stream filter nodes differently
                if (source.type === 'stream-filter') {
                    const newNode = {
                        id: genId('stream-filter'),
                        type: 'stream-filter',
                        label: source.label + ' (copy)',
                        position: {
                            x: snapToGrid(source.position.x + 40),
                            y: snapToGrid(source.position.y + 40),
                        },
                        color: source.color,
                        streamFilters: (source.streamFilters || []).map(f => ({ ...f })),
                    };
                    setNodes(prev => [...prev, newNode]);
                    setSelectedIds([newNode.id]);
                    return;
                }

                // Regular node duplication
                const newNode = {
                    id: genId('node'),
                    type: source.type || 'node',
                    label: source.label + ' (copy)',
                    position: {
                        x: snapToGrid(source.position.x + 40),
                        y: snapToGrid(source.position.y + 40),
                    },
                    metrics: source.metrics.map(m => ({ ...m })),
                    color: source.color,
                    derivedMetrics: (source.derivedMetrics || []).map(dm => ({ ...dm })),
                    ...(source.csvConfig ? {
                        csvConfig: {
                            filters: (source.csvConfig.filters || []).map(f => ({ ...f })),
                            metrics: (source.csvConfig.metrics || []).map(m => ({ ...m })),
                        }
                    } : {}),
                };
                setNodes(prev => [...prev, newNode]);
                setSelectedIds([newNode.id]);
            }, [nodes]);

            // ---- Text Label CRUD ----
            const addTextLabel = useCallback((x, y) => {
                const newLabel = {
                    id: genId('text'),
                    position: { x: snapToGrid(x), y: snapToGrid(y) },
                    content: 'Text Label',
                    fontSize: 14,
                    fontWeight: 'normal',
                    fontStyle: 'normal'
                };
                setTextLabels(prev => [...prev, newLabel]);
                setSelectedIds([newLabel.id]);
            }, []);

            const updateTextLabel = useCallback((id, updates) => {
                setTextLabels(prev => prev.map(l => l.id === id ? { ...l, ...updates } : l));
            }, []);

            const deleteTextLabel = useCallback((id) => {
                setTextLabels(prev => prev.filter(l => l.id !== id));
                setSelectedIds(prev => prev.filter(pid => pid !== id));
            }, []);

            const duplicateTextLabel = useCallback((id) => {
                const source = textLabels.find(l => l.id === id);
                if (!source) return;
                const newLabel = {
                    ...source,
                    id: genId('text'),
                    position: {
                        x: snapToGrid(source.position.x + 40),
                        y: snapToGrid(source.position.y + 40)
                    }
                };
                setTextLabels(prev => [...prev, newLabel]);
                setSelectedIds([newLabel.id]);
            }, [textLabels]);

            // ---- Edge CRUD ----
            const addEdge = useCallback((fromId, toId) => {
                if (fromId === toId) return;
                setEdges(prev => {
                    if (prev.some(e => e.from === fromId && e.to === toId)) return prev;
                    const edge = {
                        id: genId('edge'),
                        from: fromId,
                        to: toId,
                        calculations: [],
                    };
                    setSelectedIds([edge.id]);
                    return [...prev, edge];
                });
            }, []);

            const updateEdge = useCallback((id, updates) => {
                setEdges(prev => prev.map(e => e.id === id ? { ...e, ...updates } : e));
            }, []);

            const deleteEdge = useCallback((id) => {
                setEdges(prev => prev.filter(e => e.id !== id));
                setSelectedIds(prev => prev.filter(pid => pid !== id));
            }, []);

            // ---- Canvas helpers ----
            const screenToCanvas = useCallback((clientX, clientY) => {
                const rect = viewportRef.current.getBoundingClientRect();
                return {
                    x: (clientX - rect.left - viewport.x) / viewport.zoom,
                    y: (clientY - rect.top - viewport.y) / viewport.zoom,
                };
            }, [viewport]);

            const handleCanvasMouseDown = useCallback((e) => {
                if (e.target !== e.currentTarget &&
                    !e.target.classList.contains('canvas-transform') &&
                    !e.target.closest('.edges-svg')) return;
                if (connecting) {
                    setConnecting(null);
                    return;
                }
                if (panActiveRef.current) return;

                // Check if we should pan: spacebar override, middle-click, or hand mode
                const shouldPan = spacebarPressedRef.current || e.button === 1 || cursorMode === 'hand';

                if (shouldPan) {
                    // Panning mode
                    panActiveRef.current = true;
                    setIsPanning(true);
                    const startX = e.clientX;
                    const startY = e.clientY;
                    const vp = viewportStateRef.current;
                    const startVX = vp.x;
                    const startVY = vp.y;

                    function onMove(ev) {
                        setViewport(v => ({
                            ...v,
                            x: startVX + (ev.clientX - startX),
                            y: startVY + (ev.clientY - startY),
                        }));
                    }
                    function onUp() {
                        panActiveRef.current = false;
                        setIsPanning(false);
                        window.removeEventListener('mousemove', onMove);
                        window.removeEventListener('mouseup', onUp);
                    }
                    window.addEventListener('mousemove', onMove);
                    window.addEventListener('mouseup', onUp);
                } else {
                    // Selection box mode — use inline coordinate conversion to avoid stale closures
                    const rect = viewportRef.current.getBoundingClientRect();
                    const v = viewportStateRef.current;
                    const startPos = {
                        x: (e.clientX - rect.left - v.x) / v.zoom,
                        y: (e.clientY - rect.top - v.y) / v.zoom,
                    };
                    const shiftHeld = e.shiftKey;

                    // Clear selection if shift is not held
                    if (!shiftHeld) {
                        setSelectedIds([]);
                    }

                    setSelectionBox({
                        startX: startPos.x,
                        startY: startPos.y,
                        currentX: startPos.x,
                        currentY: startPos.y,
                    });

                    function onMove(ev) {
                        const vNow = viewportStateRef.current;
                        const r = viewportRef.current.getBoundingClientRect();
                        const currentPos = {
                            x: (ev.clientX - r.left - vNow.x) / vNow.zoom,
                            y: (ev.clientY - r.top - vNow.y) / vNow.zoom,
                        };
                        setSelectionBox(prev => prev ? {
                            ...prev,
                            currentX: currentPos.x,
                            currentY: currentPos.y,
                        } : null);
                    }

                    function onUp(ev) {
                        const vNow = viewportStateRef.current;
                        const r = viewportRef.current.getBoundingClientRect();
                        const endPos = {
                            x: (ev.clientX - r.left - vNow.x) / vNow.zoom,
                            y: (ev.clientY - r.top - vNow.y) / vNow.zoom,
                        };

                        try {
                            // Calculate selection box bounds
                            const minX = Math.min(startPos.x, endPos.x);
                            const maxX = Math.max(startPos.x, endPos.x);
                            const minY = Math.min(startPos.y, endPos.y);
                            const maxY = Math.max(startPos.y, endPos.y);

                            // Read latest nodes and textLabels from refs
                            const currentNodes = nodesRef.current;
                            const currentTextLabels = textLabelsRef.current;

                            // Find all objects that intersect with the selection box
                            const selectedNodeIds = currentNodes.filter(node => {
                                const nodeRight = node.position.x + getNodeWidth(node);
                                const nodeBottom = node.position.y + getNodeHeight(node);
                                return (
                                    node.position.x < maxX &&
                                    nodeRight > minX &&
                                    node.position.y < maxY &&
                                    nodeBottom > minY
                                );
                            }).map(n => n.id);

                            const selectedLabelIds = currentTextLabels.filter(label => {
                                const labelWidth = 100;
                                const labelHeight = 30;
                                const labelRight = label.position.x + labelWidth;
                                const labelBottom = label.position.y + labelHeight;
                                return (
                                    label.position.x < maxX &&
                                    labelRight > minX &&
                                    label.position.y < maxY &&
                                    labelBottom > minY
                                );
                            }).map(l => l.id);

                            // Add to selection (or replace if shift not held)
                            if (shiftHeld) {
                                setSelectedIds(prev => [...new Set([...prev, ...selectedNodeIds, ...selectedLabelIds])]);
                            } else {
                                setSelectedIds([...selectedNodeIds, ...selectedLabelIds]);
                            }
                        } catch (error) {
                            console.error('Error during selection box intersection test:', error);
                        } finally {
                            // Always clean up, even if an error occurred
                            setSelectionBox(null);
                            window.removeEventListener('mousemove', onMove);
                            window.removeEventListener('mouseup', onUp);
                        }
                    }

                    window.addEventListener('mousemove', onMove);
                    window.addEventListener('mouseup', onUp);
                }
            }, [connecting, cursorMode]);

            const handleCanvasDoubleClick = useCallback((e) => {
                if (e.target !== e.currentTarget && !e.target.classList.contains('canvas-transform')) return;
                const pos = screenToCanvas(e.clientX, e.clientY);
                addNode(pos.x - NODE_WIDTH / 2, pos.y - 40);
            }, [screenToCanvas, addNode]);

            const handleWheel = useCallback((e) => {
                e.preventDefault();
                setViewport(v => {
                    if (e.ctrlKey) {
                        // Pinch to zoom: smooth scaling using exponential factor
                        const zoomSpeed = 0.01;
                        const delta = Math.exp(-e.deltaY * zoomSpeed);
                        const newZoom = Math.max(0.15, Math.min(3, v.zoom * delta));

                        const rect = viewportRef.current.getBoundingClientRect();
                        const cx = e.clientX - rect.left;
                        const cy = e.clientY - rect.top;

                        return {
                            x: cx - (cx - v.x) * (newZoom / v.zoom),
                            y: cy - (cy - v.y) * (newZoom / v.zoom),
                            zoom: newZoom,
                        };
                    } else {
                        // 2-finger swipe to pan
                        return {
                            ...v,
                            x: v.x - e.deltaX,
                            y: v.y - e.deltaY,
                        };
                    }
                });
            }, []);

            useEffect(() => {
                const el = viewportRef.current;
                if (!el) return;
                el.addEventListener('wheel', handleWheel, { passive: false });
                return () => el.removeEventListener('wheel', handleWheel);
            }, [handleWheel]);

            const handleCanvasMouseMove = useCallback((e) => {
                if (connecting) {
                    const rect = viewportRef.current.getBoundingClientRect();
                    setMousePos({
                        x: (e.clientX - rect.left - viewport.x) / viewport.zoom,
                        y: (e.clientY - rect.top - viewport.y) / viewport.zoom,
                    });
                }
            }, [connecting, viewport]);

            // ---- Connection flow ----
            const startConnection = useCallback((nodeId) => {
                // Prevent connections from global filter nodes
                const node = nodes.find(n => n.id === nodeId);
                if (node && node.type === 'global-filter') {
                    return;
                }
                setConnecting({ fromId: nodeId });
                setSelectedIds([]);
            }, [nodes]);

            const endConnection = useCallback((nodeId) => {
                // Prevent connections to global filter nodes
                const targetNode = nodes.find(n => n.id === nodeId);
                if (targetNode && targetNode.type === 'global-filter') {
                    setConnecting(null);
                    return;
                }
                if (connecting && connecting.fromId !== nodeId) {
                    addEdge(connecting.fromId, nodeId);
                }
                setConnecting(null);
            }, [connecting, addEdge, nodes]);

            // ---- Import/Export ----
            const exportJSON = useCallback(() => {
                const data = JSON.stringify({ nodes, edges, csvData, textLabels }, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'funnel-builder-export.json';
                a.click();
                URL.revokeObjectURL(url);
            }, [nodes, edges, csvData]);

            const importJSON = useCallback((e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        // Apply backward compatibility migrations
                        if (data.nodes) {
                            const migratedNodes = data.nodes.map(node => {
                                const migrated = { ...node };
                                // Ensure type field exists (default to 'node' for backward compatibility)
                                if (!migrated.type) {
                                    migrated.type = 'node';
                                }
                                return migrated;
                            });
                            setNodes(migratedNodes);
                        }
                        if (data.edges) setEdges(data.edges);
                        if (data.csvData) setCsvData(data.csvData);
                        if (data.textLabels) setTextLabels(data.textLabels);
                        setSelectedIds([]);
                    } catch {
                        alert('Invalid JSON file.');
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            }, []);

            const uploadCSV = useCallback((e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const parsed = parseCSV(ev.target.result);
                        setCsvData({
                            headers: parsed.headers,
                            rows: parsed.rows,
                            rawHeaders: parsed.rawHeaders,
                            fileName: file.name,
                        });
                    } catch (err) {
                        alert('Error parsing CSV file: ' + err.message);
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            }, []);

            const clearCSV = useCallback(() => {
                setCsvData(null);
            }, []);

            const clearAll = useCallback(() => {
                setConfirmAction({
                    title: 'Clear canvas?',
                    message: 'This will remove all nodes and connections. This cannot be undone.',
                    onConfirm: () => {
                        setNodes([]);
                        setEdges([]);
                        setTextLabels([]);
                        setSelectedIds([]);
                        setConfirmAction(null);
                    },
                });
            }, []);

            // ---- Zoom controls ----
            const zoomIn = useCallback(() => {
                setViewport(v => ({ ...v, zoom: Math.min(3, v.zoom * 1.2) }));
            }, []);
            const zoomOut = useCallback(() => {
                setViewport(v => ({ ...v, zoom: Math.max(0.15, v.zoom / 1.2) }));
            }, []);
            const fitToView = useCallback(() => {
                if (nodes.length === 0) {
                    setViewport({ x: 0, y: 0, zoom: 1 });
                    return;
                }
                const rect = viewportRef.current.getBoundingClientRect();
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                nodes.forEach(n => {
                    minX = Math.min(minX, n.position.x);
                    minY = Math.min(minY, n.position.y);
                    maxX = Math.max(maxX, n.position.x + NODE_WIDTH);
                    maxY = Math.max(maxY, n.position.y + getNodeHeight(n));
                });
                const pad = 100;
                const w = maxX - minX + pad * 2;
                const h = maxY - minY + pad * 2;
                const zoom = Math.min(rect.width / w, rect.height / h, 1.5);
                const cx = (minX + maxX) / 2;
                const cy = (minY + maxY) / 2;
                setViewport({
                    x: rect.width / 2 - cx * zoom,
                    y: rect.height / 2 - cy * zoom,
                    zoom,
                });
            }, [nodes]);

            // ---- Lookup helpers ----
            const nodesById = useMemo(() => {
                const map = {};
                nodes.forEach(n => map[n.id] = n);
                return map;
            }, [nodes]);

            // ---- Compute effective metrics for nodes with CSV config ----
            const nodesWithComputedMetrics = useMemo(() => {
                // Step 0: Collect and apply global filters
                const globalFilters = collectGlobalFilters(nodes);
                const globallyFilteredRows = csvData && globalFilters.length > 0
                    ? applyFilters(csvData.rows, globalFilters)
                    : (csvData ? csvData.rows : []);

                // Step 1: Compute CSV metrics for all nodes (using globally filtered rows + stream filters)
                const nodesWithCSV = nodes.map(node => {
                    // Skip global filter nodes - they don't have CSV metrics
                    if (node.type === 'global-filter') {
                        return node;
                    }

                    // Skip stream filter nodes - they don't have CSV metrics either
                    if (node.type === 'stream-filter') {
                        return node;
                    }

                    if (csvData && node.csvConfig && node.csvConfig.metrics && node.csvConfig.metrics.length > 0) {
                        // Collect upstream stream filters for this node
                        const streamFilters = collectUpstreamStreamFilters(node.id, edges, nodesById);

                        // Apply stream filters on top of global filters
                        const streamFilteredRows = streamFilters.length > 0
                            ? applyFilters(globallyFilteredRows, streamFilters)
                            : globallyFilteredRows;

                        // Compute CSV metrics using stream-filtered rows
                        const csvMetrics = computeNodeMetrics(csvData, node.csvConfig, streamFilteredRows);
                        return { ...node, metrics: [...csvMetrics, ...(node.metrics || [])] };
                    }
                    return node;
                });

                // Step 2: Topologically sort nodes for derived metrics computation
                const { sorted, cyclic } = topologicalSort(nodesWithCSV, edges);

                // Step 3: Compute derived metrics in topological order
                const resolvedNodesMap = {};

                sorted.forEach(nodeId => {
                    const node = nodesWithCSV.find(n => n.id === nodeId);
                    if (!node) return;

                    // Compute derived metrics using already-resolved source nodes
                    const derivedMetrics = computeDerivedMetrics(node, edges, resolvedNodesMap);

                    // Merge: CSV metrics + derived metrics + manual metrics
                    const finalMetrics = [
                        ...(node.metrics || []),
                        ...derivedMetrics
                    ];

                    // Store fully-resolved node
                    resolvedNodesMap[nodeId] = { ...node, metrics: finalMetrics };
                });

                // Handle cyclic nodes (if any) - they get no derived metrics
                cyclic.forEach(nodeId => {
                    const node = nodesWithCSV.find(n => n.id === nodeId);
                    if (node && !resolvedNodesMap[nodeId]) {
                        resolvedNodesMap[nodeId] = { ...node };
                    }
                });

                // Return nodes in original order
                return nodesWithCSV.map(node => resolvedNodesMap[node.id] || node);
            }, [nodes, csvData, edges]);

            const nodesByIdWithMetrics = useMemo(() => {
                const map = {};
                nodesWithComputedMetrics.forEach(n => map[n.id] = n);
                return map;
            }, [nodesWithComputedMetrics]);

            const selectedNode = selectedIds.length === 1 && nodesById[selectedIds[0]] ? nodesById[selectedIds[0]] : null;
            const selectedEdge = selectedIds.length === 1 ? edges.find(e => e.id === selectedIds[0]) : null;

            // Multi-object move handler
            const handleMultiMove = useCallback((draggedId, newPosition) => {
                // If only one object is selected or the dragged object is not selected, just move it
                if (selectedIds.length <= 1 || !selectedIds.includes(draggedId)) {
                    const draggedNode = nodesById[draggedId];
                    const draggedLabel = textLabels.find(l => l.id === draggedId);

                    if (draggedNode) {
                        updateNode(draggedId, { position: newPosition });
                    } else if (draggedLabel) {
                        updateTextLabel(draggedId, { position: newPosition });
                    }
                    return;
                }

                // Calculate delta from the dragged object's original position
                const draggedNode = nodesById[draggedId];
                const draggedLabel = textLabels.find(l => l.id === draggedId);

                if (!draggedNode && !draggedLabel) return;

                const originalPos = draggedNode ? draggedNode.position : draggedLabel.position;
                const dx = newPosition.x - originalPos.x;
                const dy = newPosition.y - originalPos.y;

                // Apply the same delta to all selected objects
                setNodes(prev => prev.map(node => {
                    if (selectedIds.includes(node.id)) {
                        return {
                            ...node,
                            position: {
                                x: node.position.x + dx,
                                y: node.position.y + dy,
                            }
                        };
                    }
                    return node;
                }));

                setTextLabels(prev => prev.map(label => {
                    if (selectedIds.includes(label.id)) {
                        return {
                            ...label,
                            position: {
                                x: label.position.x + dx,
                                y: label.position.y + dy,
                            }
                        };
                    }
                    return label;
                }));
            }, [selectedIds, nodesById, textLabels, updateNode, updateTextLabel]);

            const gridBgStyle = {
                backgroundImage: `radial-gradient(circle, var(--grid-dot) 1px, transparent 1px)`,
                backgroundSize: `${GRID_SIZE * viewport.zoom}px ${GRID_SIZE * viewport.zoom}px`,
                backgroundPosition: `${viewport.x}px ${viewport.y}px`,
            };

            return (
                <div className="app">
                    {/* Toolbar */}
                    <div className="toolbar">
                        <a href="../../index.html" className="toolbar-back">&#8592; Back</a>
                        <div className="toolbar-sep" />
                        <span className="toolbar-title">Funnel Builder</span>
                        <div className="toolbar-sep" />
                        <div className="cursor-mode-toggle">
                            <button
                                className={`cursor-mode-btn${cursorMode === 'hand' ? ' active' : ''}`}
                                onClick={() => setCursorMode('hand')}
                                title="Hand tool (H) — drag to pan"
                            >
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                    <path d="M18 11V6a2 2 0 00-2-2 2 2 0 00-2 2v0M14 10V4a2 2 0 00-2-2 2 2 0 00-2 2v6M10 10.5V6a2 2 0 00-2-2 2 2 0 00-2 2v8" />
                                    <path d="M18 11a2 2 0 012 2v1a8 8 0 01-8 8h-1a8 8 0 01-5.66-2.34" />
                                    <path d="M6 14v-1.5" />
                                </svg>
                            </button>
                            <button
                                className={`cursor-mode-btn${cursorMode === 'select' ? ' active' : ''}`}
                                onClick={() => setCursorMode('select')}
                                title="Select tool (V) — drag to select"
                            >
                                <svg viewBox="0 0 24 24" fill="currentColor" stroke="none">
                                    <path d="M4 2l12 9.5L9.5 13 13 22l-3 1-3.5-9L2 18V2h2z" />
                                </svg>
                            </button>
                        </div>
                        <div className="toolbar-sep" />
                        <button className="toolbar-btn primary" onClick={() => {
                            const rect = viewportRef.current.getBoundingClientRect();
                            const center = screenToCanvas(rect.left + rect.width / 2, rect.top + rect.height / 2);
                            addNode(center.x - NODE_WIDTH / 2, center.y - 40);
                        }}>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="5" x2="12" y2="19" /><line x1="5" y1="12" x2="19" y2="12" /></svg>
                            Add Node
                        </button>
                        <button className="toolbar-btn" onClick={() => {
                            const rect = viewportRef.current.getBoundingClientRect();
                            const center = screenToCanvas(rect.left + rect.width / 2, rect.top + rect.height / 2);
                            addTextLabel(center.x - 50, center.y - 15);
                        }} title="Add Text Box">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                <polyline points="4 7 4 4 20 4 20 7"></polyline>
                                <line x1="9" y1="20" x2="15" y2="20"></line>
                                <line x1="12" y1="4" x2="12" y2="20"></line>
                            </svg>
                            Add Text Box
                        </button>
                        {csvData && (
                            <button className="toolbar-btn" onClick={() => {
                                const rect = viewportRef.current.getBoundingClientRect();
                                const center = screenToCanvas(rect.left + rect.width / 2, rect.top + rect.height / 2);
                                addGlobalFilterNode(center.x - NODE_WIDTH / 2, center.y - 40);
                            }} title="Add Global Filter (applies to all nodes)">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                    <path d="M3 4h18M7 9h10M10 14h4M12 19h.01" />
                                </svg>
                                Add Global Filter
                            </button>
                        )}
                        {csvData && (
                            <button className="toolbar-btn" onClick={() => {
                                const rect = viewportRef.current.getBoundingClientRect();
                                const center = screenToCanvas(rect.left + rect.width / 2, rect.top + rect.height / 2);
                                addStreamFilterNode(center.x - NODE_WIDTH / 2, center.y - 40);
                            }} title="Add Stream Filter (applies to downstream nodes)">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                    <path d="M3 4h18M7 9h10M10 14h4" />
                                    <path d="M12 14l4 4" strokeWidth="2" markerEnd="url(#arrow)" />
                                </svg>
                                Add Stream Filter
                            </button>
                        )}
                        <div className="toolbar-sep" />
                        <button className="toolbar-btn" onClick={() => fileInputRef.current.click()}>Import</button>
                        <button className="toolbar-btn" onClick={exportJSON}>Export</button>
                        <input ref={fileInputRef} type="file" accept=".json" className="hidden-input" onChange={importJSON} />
                        <div className="toolbar-sep" />
                        <button className="toolbar-btn" onClick={() => csvFileInputRef.current.click()}>
                            {csvData ? (
                                <>
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                        <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                    </svg>
                                    {csvData.fileName} ({csvData.rows.length} rows)
                                </>
                            ) : 'Upload CSV'}
                        </button>
                        {csvData && (
                            <button className="toolbar-btn" onClick={clearCSV} title="Clear CSV">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                    <line x1="18" y1="6" x2="6" y2="18" />
                                    <line x1="6" y1="6" x2="18" y2="18" />
                                </svg>
                            </button>
                        )}
                        <input ref={csvFileInputRef} type="file" accept=".csv" className="hidden-input" onChange={uploadCSV} />
                        <div className="toolbar-sep" />
                        <div className="toolbar-zoom">
                            <button className="zoom-btn" onClick={zoomOut} title="Zoom out">&#8722;</button>
                            <span className="zoom-label">{Math.round(viewport.zoom * 100)}%</span>
                            <button className="zoom-btn" onClick={zoomIn} title="Zoom in">+</button>
                            <button className="zoom-btn" onClick={fitToView} title="Fit to view">&#8862;</button>
                        </div>
                        <div className="toolbar-sep" />
                        <button className="toolbar-btn danger" onClick={clearAll}>Clear</button>
                    </div>

                    {/* Canvas */}
                    <div
                        ref={viewportRef}
                        className={`canvas-viewport${cursorMode === 'select' ? ' select-mode' : ''}${isPanning ? ' panning' : ''}${connecting ? ' connecting' : ''}`}
                        style={gridBgStyle}
                        onMouseDown={handleCanvasMouseDown}
                        onDoubleClick={handleCanvasDoubleClick}
                        onMouseMove={handleCanvasMouseMove}
                    >
                        <div className="canvas-transform" style={{
                            transform: `translate(${viewport.x}px, ${viewport.y}px) scale(${viewport.zoom})`,
                        }}>
                            {/* SVG Edges */}
                            <svg className="edges-svg">
                                <defs>
                                    <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                                        <polygon points="0 0, 8 3, 0 6" fill="#999" />
                                    </marker>
                                    <marker id="arrowhead-sel" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                                        <polygon points="0 0, 8 3, 0 6" fill="#4361ee" />
                                    </marker>
                                </defs>
                                {edges.map(edge => {
                                    const srcNode = nodesByIdWithMetrics[edge.from];
                                    const tgtNode = nodesByIdWithMetrics[edge.to];
                                    if (!srcNode || !tgtNode) return null;
                                    const src = getOutputPort(srcNode);
                                    const tgt = getInputPort(tgtNode);
                                    const path = getBezierPath(src, tgt);
                                    const isSel = selectedIds.includes(edge.id);
                                    return (
                                        <g key={edge.id}>
                                            <path d={path} fill="none" stroke="transparent" strokeWidth="16"
                                                style={{ pointerEvents: 'stroke', cursor: 'pointer' }}
                                                onClick={(e) => { e.stopPropagation(); handleSelect(edge.id, e); }}
                                            />
                                            <path d={path}
                                                className={`edge-path${isSel ? ' selected' : ''}`}
                                                markerEnd={isSel ? 'url(#arrowhead-sel)' : 'url(#arrowhead)'}
                                                onClick={(e) => { e.stopPropagation(); handleSelect(edge.id, e); }}
                                            />
                                        </g>
                                    );
                                })}
                                {connecting && (() => {
                                    const srcNode = nodesByIdWithMetrics[connecting.fromId];
                                    if (!srcNode) return null;
                                    const src = getOutputPort(srcNode);
                                    return <path d={getBezierPath(src, mousePos)} className="temp-edge" />;
                                })()}
                            </svg>

                            {/* Edge Labels */}
                            {edges.map(edge => {
                                const srcNode = nodesByIdWithMetrics[edge.from];
                                const tgtNode = nodesByIdWithMetrics[edge.to];
                                if (!srcNode || !tgtNode) return null;
                                if (!edge.calculations || edge.calculations.length === 0) return null;
                                const src = getOutputPort(srcNode);
                                const tgt = getInputPort(tgtNode);
                                const mid = bezierMidpoint(src, tgt);
                                const isSel = selectedIds.includes(edge.id);
                                return (
                                    <div key={edge.id} className="edge-label-container" style={{ left: mid.x, top: mid.y }}>
                                        <div className={`edge-label${isSel ? ' selected' : ''}`} onClick={(e) => {
                                            e.stopPropagation();
                                            setSelectedIds([edge.id]);
                                        }}>
                                            {edge.calculations.map((calc, i) => {
                                                const result = resolveExpression(calc.expression, srcNode, tgtNode);
                                                return (
                                                    <div key={i} className="edge-label-row">
                                                        {calc.label || 'Calc'}: <span className="edge-label-value">{formatNumber(result)}{calc.unit ? ` ${calc.unit}` : ''}</span>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                );
                            })}

                            {/* Selection Box */}
                            {selectionBox && (
                                <div
                                    style={{
                                        position: 'absolute',
                                        left: Math.min(selectionBox.startX, selectionBox.currentX),
                                        top: Math.min(selectionBox.startY, selectionBox.currentY),
                                        width: Math.abs(selectionBox.currentX - selectionBox.startX),
                                        height: Math.abs(selectionBox.currentY - selectionBox.startY),
                                        border: '2px dashed #4361ee',
                                        background: 'rgba(67, 97, 238, 0.1)',
                                        pointerEvents: 'none',
                                        zIndex: 1000,
                                    }}
                                />
                            )}

                            {/* Nodes */}
                            {nodesWithComputedMetrics.map(node => {
                                if (node.type === 'global-filter') {
                                    return (
                                        <GlobalFilterNode
                                            key={node.id}
                                            node={node}
                                            isSelected={selectedIds.includes(node.id)}
                                            viewportZoom={viewport.zoom}
                                            csvData={csvData}
                                            onSelect={(e) => { handleSelect(node.id, e); }}
                                            onMove={(pos) => handleMultiMove(node.id, pos)}
                                        />
                                    );
                                }
                                if (node.type === 'stream-filter') {
                                    return (
                                        <StreamFilterNode
                                            key={node.id}
                                            node={node}
                                            isSelected={selectedIds.includes(node.id)}
                                            connecting={connecting}
                                            viewportZoom={viewport.zoom}
                                            csvData={csvData}
                                            allNodes={nodes}
                                            onSelect={(e) => { handleSelect(node.id, e); }}
                                            onMove={(pos) => handleMultiMove(node.id, pos)}
                                            onStartConnection={() => startConnection(node.id)}
                                            onEndConnection={() => endConnection(node.id)}
                                        />
                                    );
                                }
                                return (
                                    <FunnelNode
                                        key={node.id}
                                        node={node}
                                        isSelected={selectedIds.includes(node.id)}
                                        connecting={connecting}
                                        viewportZoom={viewport.zoom}
                                        onSelect={(e) => { handleSelect(node.id, e); }}
                                        onMove={(pos) => handleMultiMove(node.id, pos)}
                                        onStartConnection={() => startConnection(node.id)}
                                        onEndConnection={() => endConnection(node.id)}
                                    />
                                );
                            })}
                            {textLabels.map(label => (
                                <TextLabelNode
                                    key={label.id}
                                    label={label}
                                    isSelected={selectedIds.includes(label.id)}
                                    viewportZoom={viewport.zoom}
                                    onSelect={(e) => { handleSelect(label.id, e); }}
                                    onMove={(pos) => handleMultiMove(label.id, pos)}
                                />
                            ))}
                        </div>

                        {nodes.length === 0 && textLabels.length === 0 && (
                            <div className="empty-state">
                                <h2>Build Your Funnel</h2>
                                <p>Create nodes and connect them to visualize your data flow.</p>
                                <span className="hint">Double-click anywhere or click "Add Node"</span>
                            </div>
                        )}
                    </div>

                    {/* Properties Panel */}
                    {(selectedIds.length > 0) && (
                        <div className="panel-overlay">
                            <div className="panel-header">
                                <span className="panel-title">
                                    {selectedIds.length > 1
                                        ? `Multiple Objects Selected (${selectedIds.length})`
                                        : selectedNode
                                            ? (selectedNode.type === 'global-filter' ? 'Global Filter Properties'
                                                : selectedNode.type === 'stream-filter' ? 'Stream Filter Properties'
                                                    : 'Node Properties')
                                            : selectedEdge
                                                ? 'Edge Properties'
                                                : 'Text Box Properties'}
                                </span>
                                <button className="panel-close" onClick={() => { setSelectedIds([]); }}>&times;</button>
                            </div>
                            <div className="panel-body">
                                {selectedIds.length > 1 && (
                                    <div style={{ padding: '20px', textAlign: 'center' }}>
                                        <p style={{ fontSize: '14px', color: 'var(--text-secondary)', marginBottom: '16px' }}>
                                            {selectedIds.length} objects selected
                                        </p>
                                        <div style={{ fontSize: '12px', color: 'var(--text-muted)', lineHeight: '1.6' }}>
                                            <p style={{ marginBottom: '8px' }}>You can:</p>
                                            <ul style={{ listStyle: 'none', padding: 0 }}>
                                                <li style={{ marginBottom: '4px' }}>• Move all selected objects together</li>
                                                <li style={{ marginBottom: '4px' }}>• <strong>Cmd/Ctrl+C</strong> to copy</li>
                                                <li style={{ marginBottom: '4px' }}>• <strong>Cmd/Ctrl+V</strong> to paste</li>
                                                <li style={{ marginBottom: '4px' }}>• <strong>Cmd/Ctrl+D</strong> to duplicate</li>
                                                <li style={{ marginBottom: '4px' }}>• <strong>Delete/Backspace</strong> to remove</li>
                                            </ul>
                                        </div>
                                    </div>
                                )}
                                {selectedNode && selectedNode.type === 'global-filter' && (
                                    <GlobalFilterEditor
                                        node={selectedNode}
                                        csvData={csvData}
                                        onUpdate={(updates) => updateNode(selectedNode.id, updates)}
                                        onDelete={() => deleteNode(selectedNode.id)}
                                        onDuplicate={() => duplicateNode(selectedNode.id)}
                                    />
                                )}
                                {selectedNode && selectedNode.type === 'stream-filter' && (
                                    <StreamFilterEditor
                                        node={selectedNode}
                                        csvData={csvData}
                                        allNodes={nodes}
                                        onUpdate={(updates) => updateNode(selectedNode.id, updates)}
                                        onDelete={() => deleteNode(selectedNode.id)}
                                        onDuplicate={() => duplicateNode(selectedNode.id)}
                                    />
                                )}
                                {selectedNode && selectedNode.type !== 'global-filter' && selectedNode.type !== 'stream-filter' && (
                                    <NodeEditor
                                        node={selectedNode}
                                        csvData={csvData}
                                        edges={edges}
                                        allNodes={nodesByIdWithMetrics}
                                        onUpdate={(updates) => updateNode(selectedNode.id, updates)}
                                        onDelete={() => deleteNode(selectedNode.id)}
                                        onDuplicate={() => duplicateNode(selectedNode.id)}
                                    />
                                )}
                                {selectedEdge && (
                                    <EdgeEditor
                                        edge={selectedEdge}
                                        sourceNode={nodesByIdWithMetrics[selectedEdge.from]}
                                        targetNode={nodesByIdWithMetrics[selectedEdge.to]}
                                        onUpdate={(updates) => updateEdge(selectedEdge.id, updates)}
                                        onDelete={() => deleteEdge(selectedEdge.id)}
                                    />
                                )}
                                {selectedIds.length === 1 && textLabels.some(l => l.id === selectedIds[0]) && (
                                    <TextLabelEditor
                                        label={textLabels.find(l => l.id === selectedIds[0])}
                                        onUpdate={(updates) => updateTextLabel(selectedIds[0], updates)}
                                        onDelete={() => deleteTextLabel(selectedIds[0])}
                                        onDuplicate={() => duplicateTextLabel(selectedIds[0])}
                                    />
                                )}
                            </div>
                        </div>
                    )}

                    <div className="privacy-badge">
                        Your data stays in your browser &mdash; nothing leaves your machine.
                    </div>

                    {confirmAction && (
                        <div className="confirm-overlay" onClick={() => setConfirmAction(null)}>
                            <div className="confirm-modal" onClick={e => e.stopPropagation()}>
                                <h3>{confirmAction.title}</h3>
                                <p>{confirmAction.message}</p>
                                <div className="confirm-actions">
                                    <button className="confirm-cancel" onClick={() => setConfirmAction(null)}>Cancel</button>
                                    <button className="confirm-danger" onClick={confirmAction.onConfirm}>Confirm</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        // ========================
        // FunnelNode Component
        // ========================
        function GlobalFilterNode({ node, isSelected, viewportZoom, onSelect, onMove, csvData }) {
            const [isDragging, setIsDragging] = useState(false);

            const handleMouseDown = useCallback((e) => {
                e.stopPropagation();
                if (onSelect) onSelect(e);

                setIsDragging(true);
                const startX = e.clientX;
                const startY = e.clientY;
                const startPos = { ...node.position };
                let currentPos = { ...startPos };

                function handleMove(ev) {
                    const dx = (ev.clientX - startX) / viewportZoom;
                    const dy = (ev.clientY - startY) / viewportZoom;
                    currentPos = {
                        x: startPos.x + dx,
                        y: startPos.y + dy,
                    };
                    onMove(currentPos);
                }
                function handleUp() {
                    setIsDragging(false);
                    onMove({
                        x: snapToGrid(currentPos.x),
                        y: snapToGrid(currentPos.y),
                    });
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                }
                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
            }, [node.position, viewportZoom, onSelect, onMove]);

            // Calculate row count
            const totalRows = csvData ? csvData.rows.length : 0;
            const filteredRows = csvData && node.globalFilters && node.globalFilters.length > 0
                ? applyFilters(csvData.rows, node.globalFilters).length
                : totalRows;

            const operatorLabels = {
                equals: '=',
                not_equals: '≠',
                contains: '~',
                greater_than: '>',
                less_than: '<',
            };

            return (
                <div
                    className={`global-filter-node${isSelected ? ' selected' : ''}${isDragging ? ' dragging' : ''}`}
                    style={{
                        left: node.position.x,
                        top: node.position.y,
                    }}
                    onMouseDown={handleMouseDown}
                >
                    <div className="global-filter-header">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                            <path d="M3 4h18M7 9h10M10 14h4M12 19h.01" />
                        </svg>
                        {node.label}
                    </div>
                    <div className="global-filter-body">
                        {!node.globalFilters || node.globalFilters.length === 0 ? (
                            <div className="global-filter-no-filters">No filters configured</div>
                        ) : (
                            <>
                                {node.globalFilters.map((filter, i) => (
                                    <div key={i} className="global-filter-summary">
                                        <span className="global-filter-summary-label">{filter.column}</span>
                                        <span className="global-filter-summary-operator">{operatorLabels[filter.operator] || filter.operator}</span>
                                        <span className="global-filter-summary-value">"{filter.value}"</span>
                                    </div>
                                ))}
                                {csvData && (
                                    <div className="global-filter-count">
                                        {filteredRows} of {totalRows} rows match
                                    </div>
                                )}
                            </>
                        )}
                    </div>
                </div>
            );
        }

        function StreamFilterNode({ node, isSelected, connecting, viewportZoom, onSelect, onMove, onStartConnection, onEndConnection, csvData, allNodes }) {
            const [isDragging, setIsDragging] = useState(false);

            const handleMouseDown = useCallback((e) => {
                if (e.target.closest('.node-port')) {
                    e.stopPropagation();
                    return;
                }

                // If in connecting mode and this is not the source node, complete the connection
                if (connecting && connecting.fromId !== node.id) {
                    e.stopPropagation();
                    onEndConnection();
                    return;
                }

                e.stopPropagation();
                if (onSelect) onSelect(e);

                setIsDragging(true);
                const startX = e.clientX;
                const startY = e.clientY;
                const startPos = { ...node.position };
                let currentPos = { ...startPos };

                function handleMove(ev) {
                    const dx = (ev.clientX - startX) / viewportZoom;
                    const dy = (ev.clientY - startY) / viewportZoom;
                    currentPos = {
                        x: startPos.x + dx,
                        y: startPos.y + dy,
                    };
                    onMove(currentPos);
                }
                function handleUp() {
                    setIsDragging(false);
                    onMove({
                        x: snapToGrid(currentPos.x),
                        y: snapToGrid(currentPos.y),
                    });
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                }
                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
            }, [node.position, viewportZoom, onSelect, onMove, connecting, onEndConnection]);

            // Calculate row count
            const totalRows = csvData ? csvData.rows.length : 0;
            // Apply global filters first
            const globalFilters = collectGlobalFilters(allNodes || []);
            const globallyFilteredRows = csvData && globalFilters.length > 0
                ? applyFilters(csvData.rows, globalFilters)
                : (csvData ? csvData.rows : []);
            const filteredRows = csvData && node.streamFilters && node.streamFilters.length > 0
                ? applyFilters(globallyFilteredRows, node.streamFilters).length
                : globallyFilteredRows.length;

            const operatorLabels = {
                equals: '=',
                not_equals: '≠',
                contains: '~',
                greater_than: '>',
                less_than: '<',
            };

            return (
                <div
                    className={`stream-filter-node${isSelected ? ' selected' : ''}${isDragging ? ' dragging' : ''}`}
                    style={{
                        left: node.position.x,
                        top: node.position.y,
                    }}
                    onMouseDown={handleMouseDown}
                >
                    <div className="stream-filter-header">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                            <path d="M3 4h18M7 9h10M10 14h4" />
                            <path d="M12 14l4 4" strokeWidth="2" />
                        </svg>
                        {node.label}
                    </div>
                    <div className="stream-filter-body">
                        {!node.streamFilters || node.streamFilters.length === 0 ? (
                            <div className="stream-filter-no-filters">No filters configured</div>
                        ) : (
                            <>
                                {node.streamFilters.map((filter, i) => (
                                    <div key={i} className="stream-filter-summary">
                                        <span className="stream-filter-summary-label">{filter.column}</span>
                                        <span className="stream-filter-summary-operator">{operatorLabels[filter.operator] || filter.operator}</span>
                                        <span className="stream-filter-summary-value">"{filter.value}"</span>
                                    </div>
                                ))}
                                {csvData && (
                                    <div className="stream-filter-count">
                                        {filteredRows} of {globallyFilteredRows.length} rows match
                                    </div>
                                )}
                            </>
                        )}
                    </div>
                    <div
                        className={`node-port port-input${connecting ? ' connectable' : ''}`}
                        onMouseDown={(e) => e.stopPropagation()}
                        onClick={(e) => { e.stopPropagation(); if (connecting) onEndConnection(); }}
                        title="Input"
                    />
                    <div
                        className="node-port port-output"
                        onMouseDown={(e) => e.stopPropagation()}
                        onClick={(e) => { e.stopPropagation(); onStartConnection(); }}
                        title="Output — click to connect"
                    />
                </div>
            );
        }

        function FunnelNode({ node, isSelected, connecting, viewportZoom, onSelect, onMove, onStartConnection, onEndConnection }) {
            const [isDragging, setIsDragging] = useState(false);
            const colorDef = NODE_COLORS[node.color || 0] || NODE_COLORS[0];

            const handleMouseDown = useCallback((e) => {
                if (e.target.closest('.node-port')) {
                    e.stopPropagation();
                    return;
                }

                // If in connecting mode and this is not the source node, complete the connection
                if (connecting && connecting.fromId !== node.id) {
                    e.stopPropagation();
                    onEndConnection();
                    return;
                }

                e.stopPropagation();
                if (onSelect) onSelect(e);

                setIsDragging(true);
                const startX = e.clientX;
                const startY = e.clientY;
                const startPos = { ...node.position };
                let currentPos = { ...startPos };

                function handleMove(ev) {
                    const dx = (ev.clientX - startX) / viewportZoom;
                    const dy = (ev.clientY - startY) / viewportZoom;
                    currentPos = {
                        x: startPos.x + dx,
                        y: startPos.y + dy,
                    };
                    onMove(currentPos);
                }
                function handleUp() {
                    setIsDragging(false);
                    onMove({
                        x: snapToGrid(currentPos.x),
                        y: snapToGrid(currentPos.y),
                    });
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                }
                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
            }, [node.position, viewportZoom, onSelect, onMove]);

            return (
                <div
                    className={`funnel-node${isSelected ? ' selected' : ''}${isDragging ? ' dragging' : ''}`}
                    style={{
                        left: node.position.x,
                        top: node.position.y,
                        background: colorDef.bg,
                        borderColor: isSelected ? undefined : colorDef.border,
                    }}
                    onMouseDown={handleMouseDown}
                >
                    <div className="node-header">{node.label}</div>
                    <div className="node-metrics">
                        {node.metrics.length === 0 ? (
                            <div className="node-no-metrics">No metrics defined</div>
                        ) : (
                            node.metrics.map((m, i) => (
                                <div key={i} className="node-metric">
                                    <span className="node-metric-label">{m.label || m.key}</span>
                                    <span className="node-metric-value">{formatNumber(Number(m.value))}</span>
                                </div>
                            ))
                        )}
                    </div>
                    <div
                        className={`node-port port-input${connecting ? ' connectable' : ''}`}
                        onMouseDown={(e) => e.stopPropagation()}
                        onClick={(e) => { e.stopPropagation(); if (connecting) onEndConnection(); }}
                        title="Input"
                    />
                    <div
                        className="node-port port-output"
                        onMouseDown={(e) => e.stopPropagation()}
                        onClick={(e) => { e.stopPropagation(); onStartConnection(); }}
                        title="Output — click to connect"
                    />
                </div>
            );
        }

        // ========================
        // TextLabel Components
        // ========================
        function TextLabelNode({ label, isSelected, viewportZoom, onSelect, onMove }) {
            const [isDragging, setIsDragging] = useState(false);

            const handleMouseDown = useCallback((e) => {
                e.stopPropagation();
                if (onSelect) onSelect(e);

                setIsDragging(true);
                const startX = e.clientX;
                const startY = e.clientY;
                const startPos = { ...label.position };
                let currentPos = { ...startPos };

                function handleMove(ev) {
                    const dx = (ev.clientX - startX) / viewportZoom;
                    const dy = (ev.clientY - startY) / viewportZoom;
                    currentPos = {
                        x: startPos.x + dx,
                        y: startPos.y + dy,
                    };
                    onMove(currentPos);
                }
                function handleUp() {
                    setIsDragging(false);
                    onMove({
                        x: snapToGrid(currentPos.x),
                        y: snapToGrid(currentPos.y),
                    });
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                }
                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
            }, [label.position, viewportZoom, onSelect, onMove]);

            return (
                <div
                    className={`text-label${isSelected ? ' selected' : ''}${isDragging ? ' dragging' : ''}`}
                    style={{
                        left: label.position.x,
                        top: label.position.y,
                        fontSize: `${label.fontSize || 14}px`,
                        fontWeight: label.fontWeight || 'normal',
                        fontStyle: label.fontStyle || 'normal',
                    }}
                    onMouseDown={handleMouseDown}
                >
                    <div className="text-label-content">{label.content || 'Text Label'}</div>
                </div>
            );
        }

        function TextLabelEditor({ label, onUpdate, onDelete, onDuplicate }) {
            return (
                <div>
                    <div className="panel-section">
                        <div className="panel-section-title">Text Content</div>
                        <div className="panel-field">
                            <textarea
                                value={label.content || ''}
                                onChange={e => onUpdate({ content: e.target.value })}
                                placeholder="Enter text..."
                            />
                        </div>
                    </div>

                    <div className="panel-section">
                        <div className="panel-section-title">Styling</div>
                        <div className="panel-field">
                            <label>Font Size (px)</label>
                            <input
                                type="number"
                                value={label.fontSize || 14}
                                onChange={e => onUpdate({ fontSize: Number(e.target.value) || 14 })}
                                min="8"
                                max="72"
                            />
                        </div>
                        <div className="panel-field" style={{ display: 'flex', gap: '8px', marginTop: '12px' }}>
                            <button
                                className={`toolbar-btn ${label.fontWeight === 'bold' ? 'primary' : ''}`}
                                onClick={() => onUpdate({ fontWeight: label.fontWeight === 'bold' ? 'normal' : 'bold' })}
                                style={{ flex: 1, justifyContent: 'center' }}
                            >
                                Bold
                            </button>
                            <button
                                className={`toolbar-btn ${label.fontStyle === 'italic' ? 'primary' : ''}`}
                                onClick={() => onUpdate({ fontStyle: label.fontStyle === 'italic' ? 'normal' : 'italic' })}
                                style={{ flex: 1, justifyContent: 'center' }}
                            >
                                Italic
                            </button>
                        </div>
                    </div>

                    <div className="panel-section delete-section">
                        <button className="duplicate-btn" onClick={onDuplicate}>Duplicate</button>
                        <button className="delete-btn" onClick={onDelete}>Delete</button>
                    </div>
                </div>
            );
        }

        // ========================
        // NodeEditor Component
        // ========================
        function GlobalFilterEditor({ node, csvData, onUpdate, onDelete, onDuplicate }) {
            const globalFilters = node.globalFilters || [];

            // Helper to get distinct values for a column
            const getDistinctValues = (column) => {
                if (!csvData) return [];
                const values = csvData.rows.map(row => row[column]).filter(v => v);
                return [...new Set(values)].slice(0, 20); // Limit to 20 for performance
            };

            // Helper to count globally filtered rows
            const getGlobalFilteredRowCount = () => {
                if (!csvData) return 0;
                if (globalFilters.length === 0) return csvData.rows.length;
                return applyFilters(csvData.rows, globalFilters).length;
            };

            return (
                <div>
                    <div className="panel-section">
                        <div className="panel-section-title">Label</div>
                        <div className="panel-field">
                            <input
                                value={node.label}
                                onChange={e => onUpdate({ label: e.target.value })}
                                placeholder="Global Filter label..."
                            />
                        </div>
                    </div>

                    {/* Global Filters Section */}
                    {csvData && (
                        <div className="panel-section">
                            <div className="panel-section-title">Global Filters</div>
                            <div style={{ fontSize: '11px', color: '#92400e', marginBottom: '8px', fontWeight: 500 }}>
                                {getGlobalFilteredRowCount()} of {csvData.rows.length} rows match globally
                            </div>
                            <div style={{ fontSize: '11px', color: 'var(--text-muted)', marginBottom: '12px', fontStyle: 'italic' }}>
                                These filters apply to all nodes on the canvas.
                            </div>
                            {globalFilters.map((filter, i) => (
                                <div key={i} className="metric-card filter-card">
                                    <div className="metric-card-header">
                                        <span className="metric-card-title">Filter {i + 1}</span>
                                        <button className="metric-delete-btn" onClick={() => {
                                            const filters = [...globalFilters];
                                            filters.splice(i, 1);
                                            onUpdate({ globalFilters: filters });
                                        }}>&times;</button>
                                    </div>
                                    <div className="panel-field">
                                        <label>Column</label>
                                        <select
                                            value={filter.column || ''}
                                            onChange={e => {
                                                const filters = [...globalFilters];
                                                filters[i] = { ...filter, column: e.target.value };
                                                onUpdate({ globalFilters: filters });
                                            }}
                                            style={{ width: '100%', padding: '8px 10px', fontSize: '13px', fontFamily: 'inherit', border: '1px solid var(--input-border)', borderRadius: '8px', background: 'var(--input-bg)', color: 'var(--text-primary)' }}
                                        >
                                            <option value="">-- Select column --</option>
                                            {csvData.headers.map((h, idx) => (
                                                <option key={idx} value={h}>{csvData.rawHeaders[idx]}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div className="panel-field">
                                        <label>Operator</label>
                                        <select
                                            value={filter.operator || 'equals'}
                                            onChange={e => {
                                                const filters = [...globalFilters];
                                                filters[i] = { ...filter, operator: e.target.value };
                                                onUpdate({ globalFilters: filters });
                                            }}
                                            style={{ width: '100%', padding: '8px 10px', fontSize: '13px', fontFamily: 'inherit', border: '1px solid var(--input-border)', borderRadius: '8px', background: 'var(--input-bg)', color: 'var(--text-primary)' }}
                                        >
                                            <option value="equals">Equals</option>
                                            <option value="not_equals">Not Equals</option>
                                            <option value="contains">Contains</option>
                                            <option value="greater_than">Greater Than</option>
                                            <option value="less_than">Less Than</option>
                                        </select>
                                    </div>
                                    <div className="panel-field">
                                        <label>Value</label>
                                        <input
                                            value={filter.value || ''}
                                            onChange={e => {
                                                const filters = [...globalFilters];
                                                filters[i] = { ...filter, value: e.target.value };
                                                onUpdate({ globalFilters: filters });
                                            }}
                                            list={`global-filter-values-${i}`}
                                            placeholder="Filter value..."
                                        />
                                        {filter.column && (
                                            <datalist id={`global-filter-values-${i}`}>
                                                {getDistinctValues(filter.column).map((v, idx) => (
                                                    <option key={idx} value={v} />
                                                ))}
                                            </datalist>
                                        )}
                                    </div>
                                </div>
                            ))}
                            <button className="add-btn" onClick={() => {
                                onUpdate({ globalFilters: [...globalFilters, { column: '', operator: 'equals', value: '' }] });
                            }}>
                                + Add Filter
                            </button>
                        </div>
                    )}

                    <div className="delete-section">
                        <button className="duplicate-btn" onClick={onDuplicate}>Duplicate</button>
                        <button className="delete-btn" onClick={onDelete}>Delete</button>
                    </div>
                </div>
            );
        }

        function StreamFilterEditor({ node, csvData, allNodes, onUpdate, onDelete, onDuplicate }) {
            const streamFilters = node.streamFilters || [];

            // Helper to get distinct values for a column
            const getDistinctValues = (column) => {
                if (!csvData) return [];
                const values = csvData.rows.map(row => row[column]).filter(v => v);
                return [...new Set(values)].slice(0, 20); // Limit to 20 for performance
            };

            // Helper to count stream filtered rows
            const getStreamFilteredRowCount = () => {
                if (!csvData) return 0;
                // Apply global filters first
                const globalFilters = collectGlobalFilters(allNodes || []);
                const globallyFilteredRows = globalFilters.length > 0
                    ? applyFilters(csvData.rows, globalFilters)
                    : csvData.rows;

                if (streamFilters.length === 0) return globallyFilteredRows.length;
                return applyFilters(globallyFilteredRows, streamFilters).length;
            };

            const getGlobalFilteredRowCount = () => {
                if (!csvData) return 0;
                const globalFilters = collectGlobalFilters(allNodes || []);
                return globalFilters.length > 0
                    ? applyFilters(csvData.rows, globalFilters).length
                    : csvData.rows.length;
            };

            return (
                <div>
                    <div className="panel-section">
                        <div className="panel-section-title">Label</div>
                        <div className="panel-field">
                            <input
                                value={node.label}
                                onChange={e => onUpdate({ label: e.target.value })}
                                placeholder="Stream Filter label..."
                            />
                        </div>
                    </div>

                    {/* Stream Filters Section */}
                    {csvData && (
                        <div className="panel-section">
                            <div className="panel-section-title">Stream Filters</div>
                            <div style={{ fontSize: '11px', color: '#0c4a6e', marginBottom: '8px', fontWeight: 500 }}>
                                {getStreamFilteredRowCount()} of {getGlobalFilteredRowCount()} rows match
                            </div>
                            <div style={{ fontSize: '11px', color: 'var(--text-muted)', marginBottom: '12px', fontStyle: 'italic' }}>
                                These filters apply to all downstream connected nodes.
                            </div>
                            {streamFilters.map((filter, i) => (
                                <div key={i} className="metric-card filter-card">
                                    <div className="metric-card-header">
                                        <span className="metric-card-title">Filter {i + 1}</span>
                                        <button className="metric-delete-btn" onClick={() => {
                                            const filters = [...streamFilters];
                                            filters.splice(i, 1);
                                            onUpdate({ streamFilters: filters });
                                        }}>&times;</button>
                                    </div>
                                    <div className="panel-field">
                                        <label>Column</label>
                                        <select
                                            value={filter.column || ''}
                                            onChange={e => {
                                                const filters = [...streamFilters];
                                                filters[i] = { ...filter, column: e.target.value };
                                                onUpdate({ streamFilters: filters });
                                            }}
                                            style={{ width: '100%', padding: '8px 10px', fontSize: '13px', fontFamily: 'inherit', border: '1px solid var(--input-border)', borderRadius: '8px', background: 'var(--input-bg)', color: 'var(--text-primary)' }}
                                        >
                                            <option value="">-- Select column --</option>
                                            {csvData.headers.map((h, idx) => (
                                                <option key={idx} value={h}>{csvData.rawHeaders[idx]}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div className="panel-field">
                                        <label>Operator</label>
                                        <select
                                            value={filter.operator || 'equals'}
                                            onChange={e => {
                                                const filters = [...streamFilters];
                                                filters[i] = { ...filter, operator: e.target.value };
                                                onUpdate({ streamFilters: filters });
                                            }}
                                            style={{ width: '100%', padding: '8px 10px', fontSize: '13px', fontFamily: 'inherit', border: '1px solid var(--input-border)', borderRadius: '8px', background: 'var(--input-bg)', color: 'var(--text-primary)' }}
                                        >
                                            <option value="equals">Equals</option>
                                            <option value="not_equals">Not Equals</option>
                                            <option value="contains">Contains</option>
                                            <option value="greater_than">Greater Than</option>
                                            <option value="less_than">Less Than</option>
                                        </select>
                                    </div>
                                    <div className="panel-field">
                                        <label>Value</label>
                                        <input
                                            value={filter.value || ''}
                                            onChange={e => {
                                                const filters = [...streamFilters];
                                                filters[i] = { ...filter, value: e.target.value };
                                                onUpdate({ streamFilters: filters });
                                            }}
                                            list={`stream-filter-values-${i}`}
                                            placeholder="Filter value..."
                                        />
                                        {filter.column && (
                                            <datalist id={`stream-filter-values-${i}`}>
                                                {getDistinctValues(filter.column).map((v, idx) => (
                                                    <option key={idx} value={v} />
                                                ))}
                                            </datalist>
                                        )}
                                    </div>
                                </div>
                            ))}
                            <button className="add-btn" onClick={() => {
                                onUpdate({ streamFilters: [...streamFilters, { column: '', operator: 'equals', value: '' }] });
                            }}>
                                + Add Filter
                            </button>
                        </div>
                    )}

                    <div className="delete-section">
                        <button className="duplicate-btn" onClick={onDuplicate}>Duplicate</button>
                        <button className="delete-btn" onClick={onDelete}>Delete</button>
                    </div>
                </div>
            );
        }

        function NodeEditor({ node, csvData, edges, allNodes, onUpdate, onDelete, onDuplicate }) {
            const csvConfig = node.csvConfig || { filters: [], metrics: [] };
            const derivedMetrics = node.derivedMetrics || [];

            // Helper to get distinct values for a column
            const getDistinctValues = (column) => {
                if (!csvData) return [];
                const values = csvData.rows.map(row => row[column]).filter(v => v);
                return [...new Set(values)].slice(0, 20); // Limit to 20 for performance
            };

            // Helper to count filtered rows
            const getFilteredRowCount = () => {
                if (!csvData) return 0;
                return applyFilters(csvData.rows, csvConfig.filters || []).length;
            };

            // Get incoming source nodes
            const incomingSourceNodes = edges
                .filter(e => e.to === node.id)
                .map(e => allNodes[e.from])
                .filter(n => n);

            return (
                <div>
                    <div className="panel-section">
                        <div className="panel-section-title">Label</div>
                        <div className="panel-field">
                            <input
                                value={node.label}
                                onChange={e => onUpdate({ label: e.target.value })}
                                placeholder="Node label..."
                            />
                        </div>
                    </div>

                    <div className="panel-section">
                        <div className="panel-section-title">Color</div>
                        <div className="color-picker">
                            {NODE_COLORS.map((c, i) => (
                                <div
                                    key={i}
                                    className={`color-swatch${(node.color || 0) === i ? ' active' : ''}`}
                                    style={{ background: c.bg, borderColor: c.border }}
                                    onClick={() => onUpdate({ color: i })}
                                    title={c.name}
                                />
                            ))}
                        </div>
                    </div>

                    {/* Data Filters Section */}
                    {csvData && (
                        <div className="panel-section">
                            <div className="panel-section-title">Data Filters</div>
                            <div style={{ fontSize: '11px', color: 'var(--text-muted)', marginBottom: '8px' }}>
                                {getFilteredRowCount()} of {csvData.rows.length} rows match
                            </div>
                            {(csvConfig.filters || []).map((filter, i) => (
                                <div key={i} className="metric-card filter-card">
                                    <div className="metric-card-header">
                                        <span className="metric-card-title">Filter {i + 1}</span>
                                        <button className="metric-delete-btn" onClick={() => {
                                            const filters = [...(csvConfig.filters || [])];
                                            filters.splice(i, 1);
                                            onUpdate({ csvConfig: { ...csvConfig, filters } });
                                        }}>&times;</button>
                                    </div>
                                    <div className="panel-field">
                                        <label>Column</label>
                                        <select
                                            value={filter.column || ''}
                                            onChange={e => {
                                                const filters = [...(csvConfig.filters || [])];
                                                filters[i] = { ...filter, column: e.target.value };
                                                onUpdate({ csvConfig: { ...csvConfig, filters } });
                                            }}
                                            style={{ width: '100%', padding: '8px 10px', fontSize: '13px', fontFamily: 'inherit', border: '1px solid var(--input-border)', borderRadius: '8px', background: 'var(--input-bg)', color: 'var(--text-primary)' }}
                                        >
                                            <option value="">-- Select column --</option>
                                            {csvData.headers.map((h, idx) => (
                                                <option key={idx} value={h}>{csvData.rawHeaders[idx]}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div className="panel-field">
                                        <label>Operator</label>
                                        <select
                                            value={filter.operator || 'equals'}
                                            onChange={e => {
                                                const filters = [...(csvConfig.filters || [])];
                                                filters[i] = { ...filter, operator: e.target.value };
                                                onUpdate({ csvConfig: { ...csvConfig, filters } });
                                            }}
                                            style={{ width: '100%', padding: '8px 10px', fontSize: '13px', fontFamily: 'inherit', border: '1px solid var(--input-border)', borderRadius: '8px', background: 'var(--input-bg)', color: 'var(--text-primary)' }}
                                        >
                                            <option value="equals">Equals</option>
                                            <option value="not_equals">Not Equals</option>
                                            <option value="contains">Contains</option>
                                            <option value="greater_than">Greater Than</option>
                                            <option value="less_than">Less Than</option>
                                        </select>
                                    </div>
                                    <div className="panel-field">
                                        <label>Value</label>
                                        <input
                                            list={`filter-${i}-values`}
                                            value={filter.value || ''}
                                            onChange={e => {
                                                const filters = [...(csvConfig.filters || [])];
                                                filters[i] = { ...filter, value: e.target.value };
                                                onUpdate({ csvConfig: { ...csvConfig, filters } });
                                            }}
                                            placeholder="Enter value..."
                                        />
                                        <datalist id={`filter-${i}-values`}>
                                            {filter.column && getDistinctValues(filter.column).map((val, vi) => (
                                                <option key={vi} value={val} />
                                            ))}
                                        </datalist>
                                    </div>
                                </div>
                            ))}
                            <button className="add-btn" onClick={() => {
                                const filters = [...(csvConfig.filters || []), { column: '', operator: 'equals', value: '' }];
                                onUpdate({ csvConfig: { ...csvConfig, filters } });
                            }}>+ Add Filter</button>
                        </div>
                    )}

                    {/* CSV Metrics Section */}
                    {csvData && (
                        <div className="panel-section">
                            <div className="panel-section-title">CSV Metrics</div>
                            {(csvConfig.metrics || []).map((metric, i) => {
                                const filteredRows = applyFilters(csvData.rows, csvConfig.filters || []);
                                const computedValue = aggregate(filteredRows, metric.column, metric.aggregation);
                                return (
                                    <div key={i} className="metric-card csv-metric-card">
                                        <div className="metric-card-header">
                                            <span className="metric-card-title">CSV Metric {i + 1}</span>
                                            <button className="metric-delete-btn" onClick={() => {
                                                const metrics = [...(csvConfig.metrics || [])];
                                                metrics.splice(i, 1);
                                                onUpdate({ csvConfig: { ...csvConfig, metrics } });
                                            }}>&times;</button>
                                        </div>
                                        <div className="panel-field">
                                            <label>Column</label>
                                            <select
                                                value={metric.column || ''}
                                                onChange={e => {
                                                    const metrics = [...(csvConfig.metrics || [])];
                                                    const col = e.target.value;
                                                    const colIdx = csvData.headers.indexOf(col);
                                                    const rawName = csvData.rawHeaders[colIdx] || col;
                                                    const agg = metrics[i].aggregation || 'SUM';
                                                    metrics[i] = {
                                                        ...metric,
                                                        column: col,
                                                        key: metric.key || `${agg.toLowerCase()}_${col}`,
                                                        label: metric.label || `${agg} of ${rawName}`,
                                                    };
                                                    onUpdate({ csvConfig: { ...csvConfig, metrics } });
                                                }}
                                                style={{ width: '100%', padding: '8px 10px', fontSize: '13px', fontFamily: 'inherit', border: '1px solid var(--input-border)', borderRadius: '8px', background: 'var(--input-bg)', color: 'var(--text-primary)' }}
                                            >
                                                <option value="">-- Select column --</option>
                                                {csvData.headers.map((h, idx) => (
                                                    <option key={idx} value={h}>{csvData.rawHeaders[idx]}</option>
                                                ))}
                                            </select>
                                        </div>
                                        <div className="panel-field">
                                            <label>Aggregation</label>
                                            <select
                                                value={metric.aggregation || 'SUM'}
                                                onChange={e => {
                                                    const metrics = [...(csvConfig.metrics || [])];
                                                    const agg = e.target.value;
                                                    const col = metrics[i].column;
                                                    const colIdx = csvData.headers.indexOf(col);
                                                    const rawName = csvData.rawHeaders[colIdx] || col;
                                                    metrics[i] = {
                                                        ...metric,
                                                        aggregation: agg,
                                                        key: metric.key || `${agg.toLowerCase()}_${col}`,
                                                        label: metric.label || `${agg} of ${rawName}`,
                                                    };
                                                    onUpdate({ csvConfig: { ...csvConfig, metrics } });
                                                }}
                                                style={{ width: '100%', padding: '8px 10px', fontSize: '13px', fontFamily: 'inherit', border: '1px solid var(--input-border)', borderRadius: '8px', background: 'var(--input-bg)', color: 'var(--text-primary)' }}
                                            >
                                                {AGGREGATION_TYPES.map(agg => (
                                                    <option key={agg} value={agg}>{agg}</option>
                                                ))}
                                            </select>
                                        </div>
                                        <div className="panel-field">
                                            <label>Key (for expressions)</label>
                                            <input
                                                value={metric.key || ''}
                                                onChange={e => {
                                                    const metrics = [...(csvConfig.metrics || [])];
                                                    metrics[i] = { ...metric, key: e.target.value.replace(/[^a-zA-Z0-9_]/g, '').toLowerCase() };
                                                    onUpdate({ csvConfig: { ...csvConfig, metrics } });
                                                }}
                                                placeholder="e.g. sum_lead_count"
                                            />
                                        </div>
                                        <div className="panel-field">
                                            <label>Display Label</label>
                                            <input
                                                value={metric.label || ''}
                                                onChange={e => {
                                                    const metrics = [...(csvConfig.metrics || [])];
                                                    metrics[i] = { ...metric, label: e.target.value };
                                                    onUpdate({ csvConfig: { ...csvConfig, metrics } });
                                                }}
                                                placeholder="e.g. Total Leads"
                                            />
                                        </div>
                                        <div className="panel-field">
                                            <label>Computed Value</label>
                                            <input
                                                value={formatNumber(computedValue)}
                                                readOnly
                                                style={{ background: '#f0f0f0', fontWeight: 600, color: 'var(--primary)' }}
                                            />
                                        </div>
                                    </div>
                                );
                            })}
                            <button className="add-btn" onClick={() => {
                                const metrics = [...(csvConfig.metrics || []), { column: '', aggregation: 'SUM', key: '', label: '' }];
                                onUpdate({ csvConfig: { ...csvConfig, metrics } });
                            }}>+ Add CSV Metric</button>
                        </div>
                    )}

                    {/* Derived Metrics Section */}
                    {(incomingSourceNodes.length > 0 || derivedMetrics.length > 0) && (
                        <div className="panel-section">
                            <div className="panel-section-title">Derived Metrics</div>
                            {derivedMetrics.map((dm, i) => {
                                // Build source ref map for computing current value
                                const sourceRefMap = {};
                                const labelCounts = {};

                                // First pass: count labels
                                incomingSourceNodes.forEach(sourceNode => {
                                    const sanitized = sanitizeLabel(sourceNode.label);
                                    labelCounts[sanitized] = (labelCounts[sanitized] || 0) + 1;
                                });

                                // Second pass: build map with disambiguation
                                const usedLabels = {};
                                incomingSourceNodes.forEach(sourceNode => {
                                    const sanitized = sanitizeLabel(sourceNode.label);
                                    let finalLabel = sanitized;

                                    if (labelCounts[sanitized] > 1) {
                                        const count = (usedLabels[sanitized] || 0) + 1;
                                        usedLabels[sanitized] = count;
                                        finalLabel = count === 1 ? sanitized : `${sanitized}_${count}`;
                                    }

                                    sourceRefMap[finalLabel] = sourceNode;
                                });

                                // Add 'source' alias if exactly one source
                                if (incomingSourceNodes.length === 1) {
                                    sourceRefMap['source'] = incomingSourceNodes[0];
                                }

                                // Detect if any referenced identifiers are disconnected
                                const referencedIdentifiers = [];
                                const expressionPattern = /(\w+)\.(\w+)/g;
                                let match;
                                const expr = dm.expression || '';
                                while ((match = expressionPattern.exec(expr)) !== null) {
                                    const identifier = match[1];
                                    if (!referencedIdentifiers.includes(identifier)) {
                                        referencedIdentifiers.push(identifier);
                                    }
                                }

                                const disconnectedRefs = referencedIdentifiers.filter(id => !sourceRefMap[id]);
                                const isDisconnected = disconnectedRefs.length > 0;

                                // Compute the current value
                                let computedValue = 0;
                                if (incomingSourceNodes.length > 0) {
                                    let resolved = dm.expression || '';
                                    resolved = resolved.replace(/(\w+)\.(\w+)/g, (match, identifier, key) => {
                                        const sourceNode = sourceRefMap[identifier];
                                        if (!sourceNode) return '0';

                                        const m = sourceNode.metrics.find(m => m.key === key);
                                        return m ? String(Number(m.value) || 0) : '0';
                                    });
                                    computedValue = safeEvaluate(resolved);
                                }

                                return (
                                    <div key={i} className={`metric-card derived-metric-card${isDisconnected ? ' disconnected' : ''}`}>
                                        <div className="metric-card-header">
                                            <span className="metric-card-title">Derived Metric {i + 1}</span>
                                            <button className="metric-delete-btn" onClick={() => {
                                                const newDerived = [...derivedMetrics];
                                                newDerived.splice(i, 1);
                                                onUpdate({ derivedMetrics: newDerived });
                                            }}>&times;</button>
                                        </div>
                                        {isDisconnected && (
                                            <div style={{ fontSize: '11px', color: '#e63946', marginBottom: '8px', padding: '4px 8px', background: '#fff0f0', borderRadius: '6px' }}>
                                                ⚠ Referenced node(s) disconnected: {disconnectedRefs.join(', ')}
                                            </div>
                                        )}
                                        {incomingSourceNodes.length === 0 && (
                                            <div style={{ fontSize: '11px', color: '#e63946', marginBottom: '8px', padding: '4px 8px', background: '#fff0f0', borderRadius: '6px' }}>
                                                ⚠ No source nodes connected
                                            </div>
                                        )}
                                        {incomingSourceNodes.length > 0 && (
                                            <div className="var-hint" style={{ marginBottom: '8px', maxHeight: '120px', overflowY: 'auto' }}>
                                                <strong>Available metrics:</strong><br />
                                                {incomingSourceNodes.map((sourceNode, si) => {
                                                    const sanitized = sanitizeLabel(sourceNode.label);
                                                    const finalLabel = sourceRefMap[sanitized] === sourceNode
                                                        ? sanitized
                                                        : Object.keys(sourceRefMap).find(k => sourceRefMap[k] === sourceNode);

                                                    return (
                                                        <div key={si} style={{ marginTop: si > 0 ? '6px' : '0' }}>
                                                            <em style={{ fontSize: '10px', color: 'var(--text-muted)' }}>
                                                                {sourceNode.label}:
                                                            </em><br />
                                                            {sourceNode.metrics.length > 0
                                                                ? sourceNode.metrics.map((m, mi) => (
                                                                    <span key={mi}>
                                                                        <code>{finalLabel}.{m.key || '?'}</code>
                                                                        {mi < sourceNode.metrics.length - 1 ? ', ' : ''}
                                                                    </span>
                                                                ))
                                                                : <span style={{ fontSize: '11px', color: 'var(--text-muted)' }}>No metrics</span>
                                                            }
                                                        </div>
                                                    );
                                                })}
                                                {incomingSourceNodes.length === 1 && (
                                                    <div style={{ marginTop: '6px', fontSize: '10px', color: 'var(--text-muted)' }}>
                                                        <em>Tip: Use <code>source.&lt;key&gt;</code> as shorthand</em>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                        <div className="panel-field">
                                            <label>Key (for expressions)</label>
                                            <input
                                                value={dm.key || ''}
                                                onChange={e => {
                                                    const newDerived = [...derivedMetrics];
                                                    newDerived[i] = { ...dm, key: e.target.value.replace(/[^a-zA-Z0-9_]/g, '').toLowerCase() };
                                                    onUpdate({ derivedMetrics: newDerived });
                                                }}
                                                placeholder="e.g. converted"
                                            />
                                        </div>
                                        <div className="panel-field">
                                            <label>Display Label</label>
                                            <input
                                                value={dm.label || ''}
                                                onChange={e => {
                                                    const newDerived = [...derivedMetrics];
                                                    newDerived[i] = { ...dm, label: e.target.value };
                                                    onUpdate({ derivedMetrics: newDerived });
                                                }}
                                                placeholder="e.g. Converted Leads"
                                            />
                                        </div>
                                        <div className="panel-field">
                                            <label>Expression</label>
                                            <textarea
                                                value={dm.expression || ''}
                                                onChange={e => {
                                                    const newDerived = [...derivedMetrics];
                                                    newDerived[i] = { ...dm, expression: e.target.value };
                                                    onUpdate({ derivedMetrics: newDerived });
                                                }}
                                                placeholder={incomingSourceNodes.length > 1
                                                    ? "e.g. facebook_ads.lead_count + google_ads.lead_count"
                                                    : "e.g. source.lead_count * 0.05"}
                                                style={{ minHeight: '60px' }}
                                            />
                                        </div>
                                        <div className="panel-field">
                                            <label>Computed Value</label>
                                            <input
                                                value={formatNumber(computedValue)}
                                                readOnly
                                                style={{ background: '#f0f0f0', fontWeight: 600, color: 'var(--primary)' }}
                                            />
                                        </div>
                                    </div>
                                );
                            })}
                            <button className="add-btn" onClick={() => {
                                const newDerived = [...derivedMetrics, { key: '', label: '', expression: '' }];
                                onUpdate({ derivedMetrics: newDerived });
                            }}>+ Add Derived Metric</button>
                        </div>
                    )}

                    {/* Manual Metrics Section */}
                    <div className="panel-section">
                        <div className="panel-section-title">{csvData && csvConfig.metrics && csvConfig.metrics.length > 0 ? 'Additional Metrics' : 'Metrics'}</div>
                        {node.metrics.map((m, i) => (
                            <div key={i} className="metric-card">
                                <div className="metric-card-header">
                                    <span className="metric-card-title">Metric {i + 1}</span>
                                    <button className="metric-delete-btn" onClick={() => {
                                        const metrics = [...node.metrics];
                                        metrics.splice(i, 1);
                                        onUpdate({ metrics });
                                    }}>&times;</button>
                                </div>
                                <div className="panel-field">
                                    <label>Key (for expressions)</label>
                                    <input
                                        value={m.key}
                                        onChange={e => {
                                            const metrics = [...node.metrics];
                                            metrics[i] = { ...m, key: e.target.value.replace(/[^a-zA-Z0-9_]/g, '').toLowerCase() };
                                            onUpdate({ metrics });
                                        }}
                                        placeholder="e.g. lead_count"
                                    />
                                </div>
                                <div className="panel-field">
                                    <label>Display Label</label>
                                    <input
                                        value={m.label}
                                        onChange={e => {
                                            const metrics = [...node.metrics];
                                            metrics[i] = { ...m, label: e.target.value };
                                            onUpdate({ metrics });
                                        }}
                                        placeholder="e.g. Lead Count"
                                    />
                                </div>
                                <div className="panel-field">
                                    <label>Value</label>
                                    <input
                                        type="number"
                                        value={m.value}
                                        onChange={e => {
                                            const metrics = [...node.metrics];
                                            metrics[i] = { ...m, value: e.target.value };
                                            onUpdate({ metrics });
                                        }}
                                        placeholder="0"
                                    />
                                </div>
                            </div>
                        ))}
                        <button className="add-btn" onClick={() => {
                            onUpdate({ metrics: [...node.metrics, { key: '', label: '', value: 0 }] });
                        }}>+ Add Metric</button>
                    </div>

                    <div className="delete-section">
                        <button className="duplicate-btn" onClick={onDuplicate}>Duplicate</button>
                        <button className="delete-btn" onClick={onDelete}>Delete</button>
                    </div>
                </div>
            );
        }

        // ========================
        // EdgeEditor Component
        // ========================
        function EdgeEditor({ edge, sourceNode, targetNode, onUpdate, onDelete }) {
            if (!sourceNode || !targetNode) return null;

            return (
                <div>
                    <div className="panel-section">
                        <div className="panel-section-title">Connection</div>
                        <div className="edge-info">
                            From: <span>{sourceNode.label}</span><br />
                            To: <span>{targetNode.label}</span>
                        </div>
                    </div>

                    <div className="panel-section">
                        <div className="panel-section-title">Calculations</div>
                        {edge.calculations.map((calc, i) => {
                            const result = resolveExpression(calc.expression, sourceNode, targetNode);
                            return (
                                <div key={i} className="metric-card">
                                    <div className="metric-card-header">
                                        <span className="metric-card-title">Calculation {i + 1}</span>
                                        <button className="metric-delete-btn" onClick={() => {
                                            const calculations = [...edge.calculations];
                                            calculations.splice(i, 1);
                                            onUpdate({ calculations });
                                        }}>&times;</button>
                                    </div>
                                    <div className="panel-field">
                                        <label>Label</label>
                                        <input
                                            value={calc.label}
                                            onChange={e => {
                                                const calculations = [...edge.calculations];
                                                calculations[i] = { ...calc, label: e.target.value };
                                                onUpdate({ calculations });
                                            }}
                                            placeholder="e.g. Conversion Rate"
                                        />
                                    </div>
                                    <div className="panel-field">
                                        <label>Expression</label>
                                        <textarea
                                            value={calc.expression}
                                            onChange={e => {
                                                const calculations = [...edge.calculations];
                                                calculations[i] = { ...calc, expression: e.target.value };
                                                onUpdate({ calculations });
                                            }}
                                            placeholder="e.g. (target.purchasers / source.lead_count) * 100"
                                        />
                                    </div>
                                    <div className="panel-field">
                                        <label>Unit</label>
                                        <input
                                            value={calc.unit || ''}
                                            onChange={e => {
                                                const calculations = [...edge.calculations];
                                                calculations[i] = { ...calc, unit: e.target.value };
                                                onUpdate({ calculations });
                                            }}
                                            placeholder="e.g. %, Days"
                                        />
                                    </div>
                                    <div className="calc-result">
                                        Result: <strong>{formatNumber(result)}{calc.unit ? ` ${calc.unit}` : ''}</strong>
                                    </div>
                                </div>
                            );
                        })}
                        <button className="add-btn" onClick={() => {
                            onUpdate({ calculations: [...edge.calculations, { label: '', expression: '', unit: '' }] });
                        }}>+ Add Calculation</button>
                    </div>

                    <div className="panel-section">
                        <div className="panel-section-title">Available Variables</div>
                        <div className="var-hint">
                            <strong>Source ({sourceNode.label}):</strong><br />
                            {sourceNode.metrics.length > 0
                                ? sourceNode.metrics.map((m, i) => (
                                    <span key={i}><code>source.{m.key || '?'}</code>{i < sourceNode.metrics.length - 1 ? ', ' : ''}</span>
                                ))
                                : <em>No metrics</em>
                            }<br /><br />
                            <strong>Target ({targetNode.label}):</strong><br />
                            {targetNode.metrics.length > 0
                                ? targetNode.metrics.map((m, i) => (
                                    <span key={i}><code>target.{m.key || '?'}</code>{i < targetNode.metrics.length - 1 ? ', ' : ''}</span>
                                ))
                                : <em>No metrics</em>
                            }
                        </div>
                    </div>

                    <div className="delete-section">
                        <button className="delete-btn" onClick={onDelete}>Delete Connection</button>
                    </div>
                </div>
            );
        }

        // ========================
        // Render
        // ========================
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>

</html>